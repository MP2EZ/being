{
  "timestamp": "2025-09-15T09:50:05.663Z",
  "overallCoverage": 100,
  "totalFiles": 11,
  "existingFiles": 11,
  "filesWithTests": 11,
  "results": {
    "crisisSafety": {
      "name": "Crisis Safety Testing",
      "icon": "ðŸš¨",
      "files": [
        {
          "path": "src/components/accessibility/__tests__/PaymentAccessibilityTests.tsx",
          "exists": true,
          "content": "/**\n * Payment Accessibility Testing Suite - WCAG AA Compliance Validation\n *\n * TESTING COVERAGE:\n * - WCAG 2.1 AA compliance verification\n * - Screen reader compatibility across VoiceOver/TalkBack\n * - Crisis safety feature accessibility\n * - High contrast and reduced motion support\n * - Keyboard navigation and focus management\n * - Color contrast ratio validation\n * - Touch target size verification (44px minimum)\n */\n\nimport React from 'react';\nimport { render, fireEvent, waitFor } from '@testing-library/react-native';\nimport { AccessibilityInfo, Linking } from 'react-native';\nimport { PaymentAccessibilityProvider } from '../PaymentAccessibilityProvider';\nimport { AccessiblePaymentForm } from '../AccessiblePaymentForm';\nimport { PaymentAccessibilityOverlay } from '../PaymentAccessibilityOverlay';\nimport TherapeuticPaymentMessaging from '../../payment/TherapeuticPaymentMessaging';\n\n// Mock external dependencies\njest.mock('react-native', () => ({\n  ...jest.requireActual('react-native'),\n  AccessibilityInfo: {\n    isScreenReaderEnabled: jest.fn(),\n    isReduceMotionEnabled: jest.fn(),\n    announceForAccessibility: jest.fn(),\n    setAccessibilityFocus: jest.fn(),\n    addEventListener: jest.fn(() => ({ remove: jest.fn() })),\n  },\n  Appearance: {\n    getColorScheme: jest.fn(() => 'light'),\n    addChangeListener: jest.fn(() => ({ remove: jest.fn() })),\n  },\n  Linking: {\n    openURL: jest.fn(),\n  },\n}));\n\njest.mock('../../store', () => ({\n  useCrisisPaymentSafety: () => ({\n    crisisMode: false,\n    crisisOverride: null,\n    enableCrisisMode: jest.fn(),\n    performanceMetrics: {},\n  }),\n}));\n\nconst mockAccessibilityInfo = AccessibilityInfo as jest.Mocked<typeof AccessibilityInfo>;\nconst mockLinking = Linking as jest.Mocked<typeof Linking>;\n\ndescribe('Payment Accessibility Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(false);\n    mockAccessibilityInfo.isReduceMotionEnabled.mockResolvedValue(false);\n  });\n\n  describe('WCAG AA Compliance', () => {\n    test('all interactive elements meet 44px minimum touch target', async () => {\n      const { getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const buttons = getAllByRole('button');\n\n      // Check each button meets minimum touch target size\n      buttons.forEach(button => {\n        const style = button.props.style;\n        const minHeight = Array.isArray(style)\n          ? style.find(s => s && s.minHeight)?.minHeight\n          : style?.minHeight;\n\n        expect(minHeight).toBeGreaterThanOrEqual(44);\n      });\n    });\n\n    test('crisis buttons have enhanced 48px touch targets', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"financial_stress\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Call 988/i);\n      const style = crisisButton.props.style;\n      const minHeight = Array.isArray(style)\n        ? style.find(s => s && s.minHeight)?.minHeight\n        : style?.minHeight;\n\n      expect(minHeight).toBeGreaterThanOrEqual(48);\n    });\n\n    test('color contrast meets 4.5:1 ratio for normal text', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"payment_success\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      expect(alert).toBeTruthy();\n\n      // Color contrast would be verified through visual testing tools\n      // Here we verify the contrast checking function exists and is used\n      expect(alert.props.accessibilityLabel).toBeTruthy();\n    });\n\n    test('crisis elements meet 7:1 contrast ratio for enhanced visibility', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"crisis_override\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      expect(alert.props.accessibilityLiveRegion).toBe('assertive');\n    });\n  });\n\n  describe('Screen Reader Compatibility', () => {\n    beforeEach(() => {\n      mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(true);\n    });\n\n    test('payment form announces progress to screen readers', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n            showProgressIndicator={true}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalledWith(\n          expect.stringContaining('Payment form progress')\n        );\n      });\n    });\n\n    test('form field errors announced with therapeutic language', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const submitButton = getByLabelText(/Complete Payment/i);\n      fireEvent.press(submitButton);\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalledWith(\n          expect.stringContaining('required'),\n          'polite'\n        );\n      });\n    });\n\n    test('crisis activation announced with assertive priority', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"financial_stress\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Activate crisis/i);\n      fireEvent.press(crisisButton);\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalledWith(\n          expect.stringContaining('Crisis support activated'),\n          'assertive'\n        );\n      });\n    });\n\n    test('therapeutic messaging uses simplified language for screen readers', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging\n            scenario=\"payment_failure\"\n            errorCode=\"insufficient_funds\"\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      const accessibilityLabel = alert.props.accessibilityLabel;\n\n      // Verify simplified language is used\n      expect(accessibilityLabel).not.toContain('insufficient funds');\n      expect(accessibilityLabel).toContain('not enough money');\n    });\n  });\n\n  describe('Crisis Safety Accessibility', () => {\n    test('988 hotline accessible within 3 seconds via multiple methods', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Call 988/i);\n\n      // Test button exists and is immediately accessible\n      expect(crisisButton).toBeTruthy();\n\n      const startTime = Date.now();\n      fireEvent.press(crisisButton);\n      const responseTime = Date.now() - startTime;\n\n      // Should be essentially instant in tests\n      expect(responseTime).toBeLessThan(100);\n      expect(mockLinking.openURL).toHaveBeenCalledWith('tel:988');\n    });\n\n    test('crisis mode prioritizes accessibility features', async () => {\n      // Mock crisis mode enabled\n      const mockCrisisStore = {\n        crisisMode: true,\n        crisisOverride: { expires: Date.now() + 86400000, crisisSessionId: 'test123' },\n        enableCrisisMode: jest.fn(),\n        performanceMetrics: {},\n      };\n\n      jest.doMock('../../store', () => ({\n        useCrisisPaymentSafety: () => mockCrisisStore,\n      }));\n\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"crisis_override\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      expect(alert.props.accessibilityLiveRegion).toBe('assertive');\n    });\n\n    test('crisis elements have enhanced hitSlop for stress situations', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"financial_stress\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Call 988/i);\n      expect(crisisButton.props.hitSlop).toEqual({\n        top: 8,\n        bottom: 8,\n        left: 8,\n        right: 8,\n      });\n    });\n  });\n\n  describe('High Contrast and Visual Accessibility', () => {\n    test('high contrast mode increases border widths and shadows', async () => {\n      // Mock high contrast enabled\n      mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(false);\n\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <PaymentAccessibilityOverlay\n            visible={true}\n            onClose={jest.fn()}\n            onSettingsChange={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const toggles = getAllByRole('switch');\n      const highContrastToggle = toggles.find(toggle =>\n        toggle.props.accessibilityLabel?.includes('High contrast')\n      );\n\n      expect(highContrastToggle).toBeTruthy();\n    });\n\n    test('reduced motion preferences disable animations', async () => {\n      mockAccessibilityInfo.isReduceMotionEnabled.mockResolvedValue(true);\n\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <PaymentAccessibilityOverlay\n            visible={true}\n            onClose={jest.fn()}\n            onSettingsChange={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      // Animation durations should be reduced when motion is disabled\n      // This would be tested through animation mock verification\n      expect(getByRole('dialog')).toBeTruthy();\n    });\n\n    test('color-blind support uses patterns and shapes', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <PaymentAccessibilityOverlay\n            visible={true}\n            onClose={jest.fn()}\n            onSettingsChange={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const colorBlindToggle = getByLabelText(/Color blind support/i);\n      fireEvent.press(colorBlindToggle);\n\n      // Color blind support toggle should be available\n      expect(colorBlindToggle).toBeTruthy();\n    });\n  });\n\n  describe('Keyboard Navigation', () => {\n    test('tab order prioritizes crisis elements', async () => {\n      const { getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const buttons = getAllByRole('button');\n\n      // Crisis button should be first in tab order (index 0)\n      const crisisButton = buttons.find(button =>\n        button.props.accessibilityLabel?.includes('988')\n      );\n\n      expect(crisisButton).toBeTruthy();\n    });\n\n    test('form fields have logical tab progression', async () => {\n      const { getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const textInputs = getAllByRole('text');\n\n      // Each input should have returnKeyType for navigation\n      textInputs.forEach((input, index) => {\n        const expectedReturnKey = index < textInputs.length - 1 ? 'next' : 'done';\n        expect(input.props.returnKeyType).toBe(expectedReturnKey);\n      });\n    });\n  });\n\n  describe('Cognitive Accessibility', () => {\n    test('simplified language option reduces complex terminology', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging\n            scenario=\"payment_failure\"\n            errorCode=\"authentication_required\"\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      const message = alert.props.accessibilityLabel;\n\n      // Should use \"verification\" instead of \"authentication\"\n      expect(message).toContain('verification');\n      expect(message).not.toContain('authentication');\n    });\n\n    test('therapeutic messaging provides stress-reducing context', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"retry_guidance\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      expect(alert.props.accessibilityLabel).toContain('mindful');\n      expect(alert.props.accessibilityLabel).toContain('no pressure');\n    });\n\n    test('form provides step-by-step guidance', async () => {\n      const { getByText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n            showProgressIndicator={true}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const progressText = getByText(/Payment Form Progress/i);\n      expect(progressText).toBeTruthy();\n    });\n  });\n\n  describe('Performance Requirements', () => {\n    test('screen reader announcements complete within 1 second', async () => {\n      mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(true);\n\n      const startTime = Date.now();\n\n      render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"payment_success\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalled();\n      }, { timeout: 1000 });\n\n      const responseTime = Date.now() - startTime;\n      expect(responseTime).toBeLessThan(1000);\n    });\n\n    test('crisis button response time under 200ms', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Call 988/i);\n\n      const startTime = Date.now();\n      fireEvent.press(crisisButton);\n      const responseTime = Date.now() - startTime;\n\n      expect(responseTime).toBeLessThan(200);\n      expect(mockLinking.openURL).toHaveBeenCalledWith('tel:988');\n    });\n\n    test('keyboard navigation between elements under 100ms', async () => {\n      const { getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const inputs = getAllByRole('text');\n\n      if (inputs.length > 1) {\n        const startTime = Date.now();\n        fireEvent(inputs[0], 'submitEditing');\n        const responseTime = Date.now() - startTime;\n\n        // Navigation should be nearly instantaneous\n        expect(responseTime).toBeLessThan(100);\n      }\n    });\n  });\n\n  describe('Integration Tests', () => {\n    test('payment form with all accessibility features enabled', async () => {\n      mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(true);\n      mockAccessibilityInfo.isReduceMotionEnabled.mockResolvedValue(true);\n\n      const { getByLabelText, getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n            showProgressIndicator={true}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      // Crisis support should be accessible\n      const crisisButton = getByLabelText(/Call 988/i);\n      expect(crisisButton).toBeTruthy();\n\n      // Form fields should have accessibility labels\n      const inputs = getAllByRole('text');\n      inputs.forEach(input => {\n        expect(input.props.accessibilityLabel).toBeTruthy();\n        expect(input.props.accessibilityHint).toBeTruthy();\n      });\n\n      // Progress indicator should be accessible\n      expect(getByText(/Payment Form Progress/i)).toBeTruthy();\n    });\n\n    test('therapeutic messaging with crisis escalation path', async () => {\n      const onCrisisSupport = jest.fn();\n\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging\n            scenario=\"financial_stress\"\n            onCrisisSupport={onCrisisSupport}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      // Test crisis escalation path\n      const crisisButton = getByLabelText(/Activate crisis/i);\n      fireEvent.press(crisisButton);\n\n      expect(onCrisisSupport).toHaveBeenCalled();\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalledWith(\n          expect.stringContaining('Crisis support activated'),\n          'assertive'\n        );\n      });\n    });\n  });\n});\n\n// Helper function to get all elements by role (compatibility fix)\nfunction getAllByRole(container: any, role: string) {\n  const elements = container.queryAllByRole ? container.queryAllByRole(role) : [];\n  return elements.filter((el: any) => el && el.props);\n}\n\nexport default PaymentAccessibilityTests;",
          "size": 17922,
          "lines": 548,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": true,
          "hasAsyncTests": true,
          "hasExpectations": true
        },
        {
          "path": "__tests__/store/paymentStore.test.ts",
          "exists": true,
          "content": "/**\n * Payment Store Tests\n *\n * Comprehensive test suite for payment state management including:\n * - Crisis-safe payment state handling\n * - Zustand store integration testing\n * - Persistent storage testing\n * - Payment workflow state management\n * - Crisis mode state transitions\n */\n\nimport { renderHook, act } from '@testing-library/react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport {\n  usePaymentStore,\n  usePaymentActions,\n  usePaymentStatus,\n  useCrisisPaymentSafety,\n  paymentSelectors\n} from '../../src/store/paymentStore';\nimport {\n  PaymentConfig,\n  CustomerData,\n  PaymentMethodData,\n  PaymentError\n} from '../../src/types/payment';\nimport { paymentAPIService } from '../../src/services/cloud/PaymentAPIService';\n\n// Mock dependencies\njest.mock('../../src/services/cloud/PaymentAPIService');\njest.mock('../../src/services/security/EncryptionService');\njest.mock('@react-native-async-storage/async-storage');\n\ndescribe('Payment Store', () => {\n  const mockPaymentConfig: PaymentConfig = {\n    stripe: {\n      publishableKey: 'pk_test_mock_key',\n      apiVersion: '2023-10-16',\n      timeout: 30000,\n      maxRetries: 3,\n      enableApplePay: true,\n      enableGooglePay: true\n    },\n    subscription: {\n      defaultTrialDays: 7,\n      gracePeriodDays: 3,\n      retryAttempts: 3,\n      invoiceReminders: true\n    },\n    crisis: {\n      enablePaymentBypass: true,\n      emergencyAccessDuration: 24,\n      crisisDetectionTimeout: 200,\n      hotlineAlwaysAccessible: true\n    },\n    security: {\n      enableFraudDetection: true,\n      rateLimit: {\n        maxAttemptsPerMinute: 10,\n        blockDurationMinutes: 5\n      },\n      tokenExpiry: {\n        paymentMethods: 24,\n        sessions: 2\n      }\n    },\n    compliance: {\n      pciDssLevel: '2',\n      auditRetentionYears: 7,\n      enableDetailedLogging: true,\n      hipaaCompliant: true\n    }\n  };\n\n  const mockCustomerData: CustomerData = {\n    userId: 'test_user_123',\n    email: 'test@example.com',\n    name: 'Test User',\n    metadata: {\n      appUserId: 'test_user_123',\n      deviceId: 'test_device_123',\n      registrationDate: new Date().toISOString(),\n      therapeuticConsent: true,\n      crisisContactConsent: true\n    }\n  };\n\n  const mockPaymentMethodData: PaymentMethodData = {\n    type: 'card',\n    card: {\n      number: '4242424242424242',\n      expiryMonth: 12,\n      expiryYear: 2025,\n      cvc: '123'\n    },\n    billingDetails: {\n      name: 'Test User',\n      email: 'test@example.com'\n    }\n  };\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Reset AsyncStorage\n    (AsyncStorage.getItem as jest.Mock).mockResolvedValue(null);\n    (AsyncStorage.setItem as jest.Mock).mockResolvedValue(undefined);\n    (AsyncStorage.removeItem as jest.Mock).mockResolvedValue(undefined);\n\n    // Mock payment API service\n    (paymentAPIService.initialize as jest.Mock).mockResolvedValue(undefined);\n    (paymentAPIService.isInitialized as jest.Mock).mockReturnValue(true);\n    (paymentAPIService.getAvailablePlans as jest.Mock).mockResolvedValue([]);\n  });\n\n  describe('Store Initialization', () => {\n    it('should initialize with default state', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      expect(result.current.customer).toBeNull();\n      expect(result.current.paymentMethods).toEqual([]);\n      expect(result.current.activeSubscription).toBeNull();\n      expect(result.current.availablePlans).toEqual([]);\n      expect(result.current.currentPaymentIntent).toBeNull();\n      expect(result.current.paymentInProgress).toBe(false);\n      expect(result.current.lastPaymentError).toBeNull();\n      expect(result.current.crisisMode).toBe(false);\n      expect(result.current.crisisOverride).toBeNull();\n      expect(result.current.securityValidated).toBe(false);\n    });\n\n    it('should initialize payments successfully', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.initializePayments(mockPaymentConfig);\n      });\n\n      expect(paymentAPIService.initialize).toHaveBeenCalledWith(mockPaymentConfig);\n      expect(result.current.securityValidated).toBe(true);\n    });\n\n    it('should handle initialization failure with crisis mode', async () => {\n      (paymentAPIService.initialize as jest.Mock).mockRejectedValue(\n        new Error('Initialization failed')\n      );\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.initializePayments(mockPaymentConfig);\n      });\n\n      expect(result.current.crisisMode).toBe(true);\n      expect(result.current.lastPaymentError).toBeDefined();\n      expect(result.current.lastPaymentError?.userMessage).toContain('therapeutic features remain available');\n    });\n  });\n\n  describe('Customer Management', () => {\n    it('should load customer successfully', async () => {\n      const mockCustomer = {\n        customerId: 'cus_test123',\n        userId: 'test_user_123',\n        email: 'test@example.com',\n        name: 'Test User',\n        created: new Date().toISOString()\n      };\n\n      (paymentAPIService.getCustomer as jest.Mock).mockResolvedValue(mockCustomer);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.loadCustomer('test_user_123');\n      });\n\n      expect(result.current.customer).toEqual(mockCustomer);\n      expect(result.current.loadingCustomer).toBe(false);\n    });\n\n    it('should handle customer loading during crisis mode', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode first\n      await act(async () => {\n        await result.current.enableCrisisMode('mental_health_crisis');\n      });\n\n      await act(async () => {\n        await result.current.loadCustomer('test_user_123');\n      });\n\n      expect(result.current.customer?.customerId).toContain('crisis_');\n      expect(result.current.customer?.name).toBe('Emergency Access');\n    });\n\n    it('should create customer successfully', async () => {\n      const mockCreatedCustomer = {\n        customerId: 'cus_new123',\n        userId: mockCustomerData.userId,\n        email: mockCustomerData.email,\n        name: mockCustomerData.name,\n        created: new Date().toISOString()\n      };\n\n      (paymentAPIService.createCustomer as jest.Mock).mockResolvedValue(mockCreatedCustomer);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.createCustomer(mockCustomerData);\n      });\n\n      expect(result.current.customer).toEqual(mockCreatedCustomer);\n      expect(result.current.loadingCustomer).toBe(false);\n    });\n\n    it('should update customer information', async () => {\n      const mockUpdatedCustomer = {\n        customerId: 'cus_test123',\n        userId: 'test_user_123',\n        email: 'updated@example.com',\n        name: 'Updated Name',\n        created: new Date().toISOString()\n      };\n\n      (paymentAPIService.updateCustomer as jest.Mock).mockResolvedValue(mockUpdatedCustomer);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set initial customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.updateCustomerInfo({ name: 'Updated Name' });\n      });\n\n      expect(result.current.customer).toEqual(mockUpdatedCustomer);\n    });\n  });\n\n  describe('Payment Method Management', () => {\n    it('should load payment methods successfully', async () => {\n      const mockPaymentMethods = [\n        {\n          paymentMethodId: 'pm_test123',\n          type: 'card' as const,\n          card: {\n            brand: 'visa',\n            last4: '4242',\n            expiryMonth: 12,\n            expiryYear: 2025\n          },\n          created: new Date().toISOString(),\n          fingerprint: 'test_fingerprint',\n          metadata: {\n            deviceFingerprint: 'device123',\n            riskAssessment: 'low' as const,\n            verificationStatus: 'verified' as const\n          }\n        }\n      ];\n\n      (paymentAPIService.listPaymentMethods as jest.Mock).mockResolvedValue(mockPaymentMethods);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set customer first\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.loadPaymentMethods();\n      });\n\n      expect(result.current.paymentMethods).toEqual(mockPaymentMethods);\n      expect(result.current.loadingPaymentMethods).toBe(false);\n    });\n\n    it('should handle payment method loading during crisis mode', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode\n      await act(async () => {\n        await result.current.enableCrisisMode('crisis_test');\n      });\n\n      // Set customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_crisis',\n          userId: 'crisis_user',\n          email: 'crisis@example.com',\n          name: 'Crisis User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.loadPaymentMethods();\n      });\n\n      // Should return empty array during crisis (no payment processing needed)\n      expect(result.current.paymentMethods).toEqual([]);\n    });\n\n    it('should add payment method successfully', async () => {\n      const mockPaymentMethod = {\n        paymentMethodId: 'pm_new123',\n        type: 'card' as const,\n        card: {\n          brand: 'visa',\n          last4: '4242',\n          expiryMonth: 12,\n          expiryYear: 2025\n        },\n        created: new Date().toISOString(),\n        fingerprint: 'new_fingerprint',\n        metadata: {\n          deviceFingerprint: 'device123',\n          riskAssessment: 'low' as const,\n          verificationStatus: 'verified' as const\n        }\n      };\n\n      (paymentAPIService.createPaymentMethod as jest.Mock).mockResolvedValue(mockPaymentMethod);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.addPaymentMethod(mockPaymentMethodData);\n      });\n\n      expect(result.current.paymentMethods).toContain(mockPaymentMethod);\n    });\n\n    it('should remove payment method successfully', async () => {\n      (paymentAPIService.deletePaymentMethod as jest.Mock).mockResolvedValue(undefined);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set initial payment methods\n      act(() => {\n        result.current.paymentMethods = [\n          {\n            paymentMethodId: 'pm_to_remove',\n            type: 'card',\n            created: new Date().toISOString(),\n            fingerprint: 'test',\n            metadata: {\n              deviceFingerprint: 'device',\n              riskAssessment: 'low',\n              verificationStatus: 'verified'\n            }\n          }\n        ];\n      });\n\n      await act(async () => {\n        await result.current.removePaymentMethod('pm_to_remove');\n      });\n\n      expect(result.current.paymentMethods).toEqual([]);\n    });\n\n    it('should set default payment method successfully', async () => {\n      (paymentAPIService.setDefaultPaymentMethod as jest.Mock).mockResolvedValue(undefined);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set customer and payment methods\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n        result.current.paymentMethods = [\n          {\n            paymentMethodId: 'pm_test123',\n            type: 'card',\n            created: new Date().toISOString(),\n            fingerprint: 'test',\n            metadata: {\n              deviceFingerprint: 'device',\n              riskAssessment: 'low',\n              verificationStatus: 'verified'\n            }\n          }\n        ];\n      });\n\n      await act(async () => {\n        await result.current.setDefaultPaymentMethod('pm_test123');\n      });\n\n      expect(result.current.customer?.defaultPaymentMethod).toBe('pm_test123');\n      expect(result.current.paymentMethods[0].isDefault).toBe(true);\n    });\n  });\n\n  describe('Subscription Management', () => {\n    it('should load subscription successfully', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.loadSubscription();\n      });\n\n      expect(result.current.loadingSubscription).toBe(false);\n    });\n\n    it('should create crisis subscription during crisis mode', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode\n      await act(async () => {\n        await result.current.enableCrisisMode('subscription_crisis');\n      });\n\n      // Set customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_crisis',\n          userId: 'crisis_user',\n          email: 'crisis@example.com',\n          name: 'Crisis User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.loadSubscription();\n      });\n\n      expect(result.current.activeSubscription).toBeDefined();\n      expect(result.current.activeSubscription?.subscriptionId).toContain('crisis_sub_');\n      expect(result.current.activeSubscription?.status).toBe('active');\n      expect(result.current.activeSubscription?.plan.amount).toBe(0);\n      expect(result.current.activeSubscription?.plan.features).toContain('988 hotline integration');\n    });\n\n    it('should create subscription successfully', async () => {\n      const mockSubscription = {\n        subscriptionId: 'sub_test123',\n        customerId: 'cus_test123',\n        status: 'active' as const,\n        currentPeriodStart: new Date().toISOString(),\n        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n        cancelAtPeriodEnd: false,\n        plan: {\n          planId: 'fullmind_monthly',\n          name: 'FullMind Premium Monthly',\n          description: 'Monthly subscription',\n          amount: 999,\n          currency: 'usd',\n          interval: 'month' as const,\n          features: ['All MBCT practices', 'Progress tracking']\n        }\n      };\n\n      (paymentAPIService.createSubscription as jest.Mock).mockResolvedValue(mockSubscription);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.createSubscription('fullmind_monthly', 'pm_test123', 7);\n      });\n\n      expect(result.current.activeSubscription).toEqual(mockSubscription);\n    });\n\n    it('should cancel subscription successfully', async () => {\n      const mockCanceledSubscription = {\n        subscriptionId: 'sub_test123',\n        customerId: 'cus_test123',\n        status: 'active' as const,\n        currentPeriodStart: new Date().toISOString(),\n        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n        cancelAtPeriodEnd: true,\n        plan: {\n          planId: 'fullmind_monthly',\n          name: 'FullMind Premium Monthly',\n          description: 'Monthly subscription',\n          amount: 999,\n          currency: 'usd',\n          interval: 'month' as const,\n          features: ['All MBCT practices']\n        }\n      };\n\n      (paymentAPIService.cancelSubscription as jest.Mock).mockResolvedValue(mockCanceledSubscription);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set active subscription\n      act(() => {\n        result.current.activeSubscription = {\n          subscriptionId: 'sub_test123',\n          customerId: 'cus_test123',\n          status: 'active',\n          currentPeriodStart: new Date().toISOString(),\n          currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n          cancelAtPeriodEnd: false,\n          plan: {\n            planId: 'fullmind_monthly',\n            name: 'FullMind Premium Monthly',\n            description: 'Monthly subscription',\n            amount: 999,\n            currency: 'usd',\n            interval: 'month',\n            features: ['All MBCT practices']\n          }\n        };\n      });\n\n      await act(async () => {\n        await result.current.cancelSubscription(true);\n      });\n\n      expect(result.current.activeSubscription?.cancelAtPeriodEnd).toBe(true);\n    });\n  });\n\n  describe('Crisis Management', () => {\n    it('should enable crisis mode with proper state transitions', async () => {\n      (paymentAPIService.enableCrisisMode as jest.Mock).mockResolvedValue({\n        crisisSessionId: 'crisis_session_123',\n        userId: 'test_user_123',\n        deviceId: 'test_device_123',\n        overrideReason: 'mental_health_crisis',\n        overrideType: 'full_access',\n        granted: new Date().toISOString(),\n        expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n        auditTrail: {\n          triggerEvent: 'mental_health_crisis',\n          safetyScore: 100,\n          accessGranted: ['all_therapeutic_features', 'crisis_tools', 'emergency_contacts']\n        }\n      });\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.enableCrisisMode('mental_health_crisis');\n      });\n\n      expect(result.current.crisisMode).toBe(true);\n      expect(result.current.crisisOverride).toBeDefined();\n      expect(result.current.crisisOverride?.overrideType).toBe('full_access');\n      expect(result.current.lastPaymentError).toBeNull(); // Errors cleared during crisis\n    });\n\n    it('should handle crisis mode enablement failure with local emergency mode', async () => {\n      (paymentAPIService.enableCrisisMode as jest.Mock).mockRejectedValue(\n        new Error('Crisis API failed')\n      );\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.enableCrisisMode('api_failure_crisis');\n      });\n\n      // Should still enable crisis mode locally\n      expect(result.current.crisisMode).toBe(true);\n      expect(result.current.crisisOverride).toBeDefined();\n      expect(result.current.crisisOverride?.crisisSessionId).toContain('emergency_');\n    });\n\n    it('should disable crisis mode successfully', async () => {\n      (paymentAPIService.disableCrisisMode as jest.Mock).mockResolvedValue(undefined);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode first\n      act(() => {\n        result.current.crisisMode = true;\n        result.current.crisisOverride = {\n          crisisSessionId: 'test_session',\n          userId: 'test_user',\n          deviceId: 'test_device',\n          overrideReason: 'emergency_access',\n          overrideType: 'full_access',\n          granted: new Date().toISOString(),\n          expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n          auditTrail: {\n            triggerEvent: 'test',\n            safetyScore: 100,\n            accessGranted: ['test']\n          }\n        };\n      });\n\n      await act(async () => {\n        await result.current.disableCrisisMode();\n      });\n\n      expect(result.current.crisisMode).toBe(false);\n      expect(result.current.crisisOverride).toBeNull();\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle payment errors gracefully', () => {\n      const mockError: PaymentError = {\n        type: 'card_error',\n        code: 'card_declined',\n        message: 'Your card was declined.',\n        retryable: true,\n        crisisImpact: 'degraded',\n        userMessage: 'Please try a different payment method.'\n      };\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      act(() => {\n        result.current.handlePaymentError(mockError);\n      });\n\n      expect(result.current.lastPaymentError).toEqual(mockError);\n    });\n\n    it('should provide crisis-aware error handling', () => {\n      const mockError = {\n        type: 'api_error',\n        message: 'Service unavailable'\n      };\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode\n      act(() => {\n        result.current.crisisMode = true;\n      });\n\n      act(() => {\n        result.current.handlePaymentError(mockError);\n      });\n\n      expect(result.current.lastPaymentError?.crisisImpact).toBe('none');\n      expect(result.current.lastPaymentError?.userMessage).toContain('therapeutic features remain accessible');\n    });\n\n    it('should clear payment errors', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set an error first\n      act(() => {\n        result.current.lastPaymentError = {\n          type: 'api_error',\n          code: 'test_error',\n          message: 'Test error',\n          retryable: true,\n          crisisImpact: 'none',\n          userMessage: 'Test error message'\n        };\n      });\n\n      act(() => {\n        result.current.clearPaymentError();\n      });\n\n      expect(result.current.lastPaymentError).toBeNull();\n    });\n  });\n\n  describe('UI State Management', () => {\n    it('should manage payment sheet visibility', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      act(() => {\n        result.current.showPaymentSheet();\n      });\n\n      expect(result.current.showPaymentSheet).toBe(true);\n\n      act(() => {\n        result.current.hidePaymentSheet();\n      });\n\n      expect(result.current.showPaymentSheet).toBe(false);\n    });\n\n    it('should manage subscription selector visibility', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      act(() => {\n        result.current.showSubscriptionSelector();\n      });\n\n      expect(result.current.showSubscriptionSelector).toBe(true);\n\n      act(() => {\n        result.current.hideSubscriptionSelector();\n      });\n\n      expect(result.current.showSubscriptionSelector).toBe(false);\n    });\n  });\n\n  describe('Store Reset and Cleanup', () => {\n    it('should reset store state', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set some state\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test',\n          userId: 'user_test',\n          email: 'test@example.com',\n          name: 'Test',\n          created: new Date().toISOString()\n        };\n        result.current.crisisMode = true;\n        result.current.paymentInProgress = true;\n      });\n\n      act(() => {\n        result.current.reset();\n      });\n\n      expect(result.current.customer).toBeNull();\n      expect(result.current.crisisMode).toBe(false);\n      expect(result.current.paymentInProgress).toBe(false);\n    });\n\n    it('should clear sensitive data', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set sensitive data\n      act(() => {\n        result.current.paymentMethods = [{\n          paymentMethodId: 'pm_sensitive',\n          type: 'card',\n          created: new Date().toISOString(),\n          fingerprint: 'sensitive',\n          metadata: {\n            deviceFingerprint: 'device',\n            riskAssessment: 'low',\n            verificationStatus: 'verified'\n          }\n        }];\n        result.current.currentPaymentIntent = {\n          paymentIntentId: 'pi_sensitive',\n          clientSecret: 'sensitive_secret',\n          status: 'requires_payment_method',\n          amount: 999,\n          currency: 'usd',\n          created: new Date().toISOString()\n        };\n      });\n\n      act(() => {\n        result.current.clearSensitiveData();\n      });\n\n      expect(result.current.paymentMethods).toEqual([]);\n      expect(result.current.currentPaymentIntent).toBeNull();\n    });\n  });\n\n  describe('Selectors', () => {\n    it('should get subscription status with crisis awareness', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Normal mode\n      act(() => {\n        result.current.activeSubscription = {\n          subscriptionId: 'sub_test',\n          customerId: 'cus_test',\n          status: 'active',\n          currentPeriodStart: new Date().toISOString(),\n          currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n          cancelAtPeriodEnd: false,\n          plan: {\n            planId: 'test_plan',\n            name: 'Test Plan',\n            description: 'Test',\n            amount: 999,\n            currency: 'usd',\n            interval: 'month',\n            features: []\n          }\n        };\n      });\n\n      expect(paymentSelectors.getSubscriptionStatus(result.current)).toBe('active');\n\n      // Crisis mode\n      act(() => {\n        result.current.crisisMode = true;\n      });\n\n      expect(paymentSelectors.getSubscriptionStatus(result.current)).toBe('crisis_access');\n    });\n\n    it('should get feature access with crisis consideration', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // No subscription - basic access\n      const basicAccess = paymentSelectors.getFeatureAccess(result.current);\n      expect(basicAccess.therapeuticContent).toBe(false);\n      expect(basicAccess.crisisTools).toBe(true); // Always available\n      expect(basicAccess.hotlineAccess).toBe(true); // Always available\n\n      // Crisis mode - full access\n      act(() => {\n        result.current.crisisMode = true;\n      });\n\n      const crisisAccess = paymentSelectors.getFeatureAccess(result.current);\n      expect(crisisAccess.therapeuticContent).toBe(true);\n      expect(crisisAccess.premiumFeatures).toBe(true);\n      expect(crisisAccess.crisisTools).toBe(true);\n    });\n\n    it('should get payment error with crisis awareness', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      const testError: PaymentError = {\n        type: 'api_error',\n        code: 'service_unavailable',\n        message: 'Service unavailable',\n        retryable: true,\n        crisisImpact: 'blocked',\n        userMessage: 'Service temporarily unavailable'\n      };\n\n      act(() => {\n        result.current.lastPaymentError = testError;\n      });\n\n      // Normal mode\n      const normalError = paymentSelectors.getPaymentErrorForUser(result.current);\n      expect(normalError?.crisisImpact).toBe('blocked');\n\n      // Crisis mode\n      act(() => {\n        result.current.crisisMode = true;\n      });\n\n      const crisisError = paymentSelectors.getPaymentErrorForUser(result.current);\n      expect(crisisError?.crisisImpact).toBe('none');\n      expect(crisisError?.userMessage).toContain('therapeutic and safety features remain fully accessible');\n    });\n\n    it('should get performance metrics', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      act(() => {\n        result.current.crisisMode = true;\n        result.current.activeSubscription = {\n          subscriptionId: 'sub_test',\n          customerId: 'cus_test',\n          status: 'active',\n          currentPeriodStart: new Date().toISOString(),\n          currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n          cancelAtPeriodEnd: false,\n          plan: {\n            planId: 'test_plan',\n            name: 'Test Plan',\n            description: 'Test',\n            amount: 999,\n            currency: 'usd',\n            interval: 'month',\n            features: []\n          }\n        };\n        result.current.paymentMethods = [\n          {\n            paymentMethodId: 'pm_test',\n            type: 'card',\n            created: new Date().toISOString(),\n            fingerprint: 'test',\n            metadata: {\n              deviceFingerprint: 'device',\n              riskAssessment: 'low',\n              verificationStatus: 'verified'\n            }\n          }\n        ];\n      });\n\n      const metrics = paymentSelectors.getPerformanceMetrics(result.current);\n\n      expect(metrics.crisisModeEnabled).toBe(true);\n      expect(metrics.hasActiveSubscription).toBe(true);\n      expect(metrics.paymentMethodsCount).toBe(1);\n    });\n  });\n\n  describe('Custom Hooks', () => {\n    it('should provide payment actions through usePaymentActions', () => {\n      const { result } = renderHook(() => usePaymentActions());\n\n      expect(typeof result.current.initializePayments).toBe('function');\n      expect(typeof result.current.loadCustomer).toBe('function');\n      expect(typeof result.current.enableCrisisMode).toBe('function');\n      expect(typeof result.current.showPaymentSheet).toBe('function');\n    });\n\n    it('should provide payment status through usePaymentStatus', () => {\n      const { result: storeResult } = renderHook(() => usePaymentStore());\n      const { result: statusResult } = renderHook(() => usePaymentStatus());\n\n      expect(statusResult.current.subscriptionStatus).toBe('none');\n      expect(statusResult.current.featureAccess).toBeDefined();\n      expect(statusResult.current.crisisMode).toBe(false);\n      expect(statusResult.current.isLoading).toBe(false);\n    });\n\n    it('should provide crisis payment safety through useCrisisPaymentSafety', () => {\n      const { result: storeResult } = renderHook(() => usePaymentStore());\n      const { result: crisisResult } = renderHook(() => useCrisisPaymentSafety());\n\n      expect(crisisResult.current.crisisMode).toBe(false);\n      expect(crisisResult.current.crisisOverride).toBeNull();\n      expect(typeof crisisResult.current.enableCrisisMode).toBe('function');\n      expect(typeof crisisResult.current.disableCrisisMode).toBe('function');\n      expect(crisisResult.current.featureAccess).toBeDefined();\n      expect(crisisResult.current.performanceMetrics).toBeDefined();\n    });\n  });\n});",
          "size": 30658,
          "lines": 965,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": true,
          "hasAsyncTests": true,
          "hasExpectations": true
        }
      ],
      "totalFiles": 2,
      "existingFiles": 2,
      "totalLines": 1513,
      "hasTests": 2,
      "requirements": [
        "Crisis button response time <200ms",
        "988 hotline access from all payment screens",
        "Crisis mode overrides payment restrictions",
        "Emergency feature access during failures",
        "Offline crisis functionality maintained"
      ],
      "coverage": 100
    },
    "paymentFlows": {
      "name": "Payment Flow Testing",
      "icon": "ðŸ’³",
      "files": [
        {
          "path": "__tests__/store/paymentStore.test.ts",
          "exists": true,
          "content": "/**\n * Payment Store Tests\n *\n * Comprehensive test suite for payment state management including:\n * - Crisis-safe payment state handling\n * - Zustand store integration testing\n * - Persistent storage testing\n * - Payment workflow state management\n * - Crisis mode state transitions\n */\n\nimport { renderHook, act } from '@testing-library/react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport {\n  usePaymentStore,\n  usePaymentActions,\n  usePaymentStatus,\n  useCrisisPaymentSafety,\n  paymentSelectors\n} from '../../src/store/paymentStore';\nimport {\n  PaymentConfig,\n  CustomerData,\n  PaymentMethodData,\n  PaymentError\n} from '../../src/types/payment';\nimport { paymentAPIService } from '../../src/services/cloud/PaymentAPIService';\n\n// Mock dependencies\njest.mock('../../src/services/cloud/PaymentAPIService');\njest.mock('../../src/services/security/EncryptionService');\njest.mock('@react-native-async-storage/async-storage');\n\ndescribe('Payment Store', () => {\n  const mockPaymentConfig: PaymentConfig = {\n    stripe: {\n      publishableKey: 'pk_test_mock_key',\n      apiVersion: '2023-10-16',\n      timeout: 30000,\n      maxRetries: 3,\n      enableApplePay: true,\n      enableGooglePay: true\n    },\n    subscription: {\n      defaultTrialDays: 7,\n      gracePeriodDays: 3,\n      retryAttempts: 3,\n      invoiceReminders: true\n    },\n    crisis: {\n      enablePaymentBypass: true,\n      emergencyAccessDuration: 24,\n      crisisDetectionTimeout: 200,\n      hotlineAlwaysAccessible: true\n    },\n    security: {\n      enableFraudDetection: true,\n      rateLimit: {\n        maxAttemptsPerMinute: 10,\n        blockDurationMinutes: 5\n      },\n      tokenExpiry: {\n        paymentMethods: 24,\n        sessions: 2\n      }\n    },\n    compliance: {\n      pciDssLevel: '2',\n      auditRetentionYears: 7,\n      enableDetailedLogging: true,\n      hipaaCompliant: true\n    }\n  };\n\n  const mockCustomerData: CustomerData = {\n    userId: 'test_user_123',\n    email: 'test@example.com',\n    name: 'Test User',\n    metadata: {\n      appUserId: 'test_user_123',\n      deviceId: 'test_device_123',\n      registrationDate: new Date().toISOString(),\n      therapeuticConsent: true,\n      crisisContactConsent: true\n    }\n  };\n\n  const mockPaymentMethodData: PaymentMethodData = {\n    type: 'card',\n    card: {\n      number: '4242424242424242',\n      expiryMonth: 12,\n      expiryYear: 2025,\n      cvc: '123'\n    },\n    billingDetails: {\n      name: 'Test User',\n      email: 'test@example.com'\n    }\n  };\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Reset AsyncStorage\n    (AsyncStorage.getItem as jest.Mock).mockResolvedValue(null);\n    (AsyncStorage.setItem as jest.Mock).mockResolvedValue(undefined);\n    (AsyncStorage.removeItem as jest.Mock).mockResolvedValue(undefined);\n\n    // Mock payment API service\n    (paymentAPIService.initialize as jest.Mock).mockResolvedValue(undefined);\n    (paymentAPIService.isInitialized as jest.Mock).mockReturnValue(true);\n    (paymentAPIService.getAvailablePlans as jest.Mock).mockResolvedValue([]);\n  });\n\n  describe('Store Initialization', () => {\n    it('should initialize with default state', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      expect(result.current.customer).toBeNull();\n      expect(result.current.paymentMethods).toEqual([]);\n      expect(result.current.activeSubscription).toBeNull();\n      expect(result.current.availablePlans).toEqual([]);\n      expect(result.current.currentPaymentIntent).toBeNull();\n      expect(result.current.paymentInProgress).toBe(false);\n      expect(result.current.lastPaymentError).toBeNull();\n      expect(result.current.crisisMode).toBe(false);\n      expect(result.current.crisisOverride).toBeNull();\n      expect(result.current.securityValidated).toBe(false);\n    });\n\n    it('should initialize payments successfully', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.initializePayments(mockPaymentConfig);\n      });\n\n      expect(paymentAPIService.initialize).toHaveBeenCalledWith(mockPaymentConfig);\n      expect(result.current.securityValidated).toBe(true);\n    });\n\n    it('should handle initialization failure with crisis mode', async () => {\n      (paymentAPIService.initialize as jest.Mock).mockRejectedValue(\n        new Error('Initialization failed')\n      );\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.initializePayments(mockPaymentConfig);\n      });\n\n      expect(result.current.crisisMode).toBe(true);\n      expect(result.current.lastPaymentError).toBeDefined();\n      expect(result.current.lastPaymentError?.userMessage).toContain('therapeutic features remain available');\n    });\n  });\n\n  describe('Customer Management', () => {\n    it('should load customer successfully', async () => {\n      const mockCustomer = {\n        customerId: 'cus_test123',\n        userId: 'test_user_123',\n        email: 'test@example.com',\n        name: 'Test User',\n        created: new Date().toISOString()\n      };\n\n      (paymentAPIService.getCustomer as jest.Mock).mockResolvedValue(mockCustomer);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.loadCustomer('test_user_123');\n      });\n\n      expect(result.current.customer).toEqual(mockCustomer);\n      expect(result.current.loadingCustomer).toBe(false);\n    });\n\n    it('should handle customer loading during crisis mode', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode first\n      await act(async () => {\n        await result.current.enableCrisisMode('mental_health_crisis');\n      });\n\n      await act(async () => {\n        await result.current.loadCustomer('test_user_123');\n      });\n\n      expect(result.current.customer?.customerId).toContain('crisis_');\n      expect(result.current.customer?.name).toBe('Emergency Access');\n    });\n\n    it('should create customer successfully', async () => {\n      const mockCreatedCustomer = {\n        customerId: 'cus_new123',\n        userId: mockCustomerData.userId,\n        email: mockCustomerData.email,\n        name: mockCustomerData.name,\n        created: new Date().toISOString()\n      };\n\n      (paymentAPIService.createCustomer as jest.Mock).mockResolvedValue(mockCreatedCustomer);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.createCustomer(mockCustomerData);\n      });\n\n      expect(result.current.customer).toEqual(mockCreatedCustomer);\n      expect(result.current.loadingCustomer).toBe(false);\n    });\n\n    it('should update customer information', async () => {\n      const mockUpdatedCustomer = {\n        customerId: 'cus_test123',\n        userId: 'test_user_123',\n        email: 'updated@example.com',\n        name: 'Updated Name',\n        created: new Date().toISOString()\n      };\n\n      (paymentAPIService.updateCustomer as jest.Mock).mockResolvedValue(mockUpdatedCustomer);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set initial customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.updateCustomerInfo({ name: 'Updated Name' });\n      });\n\n      expect(result.current.customer).toEqual(mockUpdatedCustomer);\n    });\n  });\n\n  describe('Payment Method Management', () => {\n    it('should load payment methods successfully', async () => {\n      const mockPaymentMethods = [\n        {\n          paymentMethodId: 'pm_test123',\n          type: 'card' as const,\n          card: {\n            brand: 'visa',\n            last4: '4242',\n            expiryMonth: 12,\n            expiryYear: 2025\n          },\n          created: new Date().toISOString(),\n          fingerprint: 'test_fingerprint',\n          metadata: {\n            deviceFingerprint: 'device123',\n            riskAssessment: 'low' as const,\n            verificationStatus: 'verified' as const\n          }\n        }\n      ];\n\n      (paymentAPIService.listPaymentMethods as jest.Mock).mockResolvedValue(mockPaymentMethods);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set customer first\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.loadPaymentMethods();\n      });\n\n      expect(result.current.paymentMethods).toEqual(mockPaymentMethods);\n      expect(result.current.loadingPaymentMethods).toBe(false);\n    });\n\n    it('should handle payment method loading during crisis mode', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode\n      await act(async () => {\n        await result.current.enableCrisisMode('crisis_test');\n      });\n\n      // Set customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_crisis',\n          userId: 'crisis_user',\n          email: 'crisis@example.com',\n          name: 'Crisis User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.loadPaymentMethods();\n      });\n\n      // Should return empty array during crisis (no payment processing needed)\n      expect(result.current.paymentMethods).toEqual([]);\n    });\n\n    it('should add payment method successfully', async () => {\n      const mockPaymentMethod = {\n        paymentMethodId: 'pm_new123',\n        type: 'card' as const,\n        card: {\n          brand: 'visa',\n          last4: '4242',\n          expiryMonth: 12,\n          expiryYear: 2025\n        },\n        created: new Date().toISOString(),\n        fingerprint: 'new_fingerprint',\n        metadata: {\n          deviceFingerprint: 'device123',\n          riskAssessment: 'low' as const,\n          verificationStatus: 'verified' as const\n        }\n      };\n\n      (paymentAPIService.createPaymentMethod as jest.Mock).mockResolvedValue(mockPaymentMethod);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.addPaymentMethod(mockPaymentMethodData);\n      });\n\n      expect(result.current.paymentMethods).toContain(mockPaymentMethod);\n    });\n\n    it('should remove payment method successfully', async () => {\n      (paymentAPIService.deletePaymentMethod as jest.Mock).mockResolvedValue(undefined);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set initial payment methods\n      act(() => {\n        result.current.paymentMethods = [\n          {\n            paymentMethodId: 'pm_to_remove',\n            type: 'card',\n            created: new Date().toISOString(),\n            fingerprint: 'test',\n            metadata: {\n              deviceFingerprint: 'device',\n              riskAssessment: 'low',\n              verificationStatus: 'verified'\n            }\n          }\n        ];\n      });\n\n      await act(async () => {\n        await result.current.removePaymentMethod('pm_to_remove');\n      });\n\n      expect(result.current.paymentMethods).toEqual([]);\n    });\n\n    it('should set default payment method successfully', async () => {\n      (paymentAPIService.setDefaultPaymentMethod as jest.Mock).mockResolvedValue(undefined);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set customer and payment methods\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n        result.current.paymentMethods = [\n          {\n            paymentMethodId: 'pm_test123',\n            type: 'card',\n            created: new Date().toISOString(),\n            fingerprint: 'test',\n            metadata: {\n              deviceFingerprint: 'device',\n              riskAssessment: 'low',\n              verificationStatus: 'verified'\n            }\n          }\n        ];\n      });\n\n      await act(async () => {\n        await result.current.setDefaultPaymentMethod('pm_test123');\n      });\n\n      expect(result.current.customer?.defaultPaymentMethod).toBe('pm_test123');\n      expect(result.current.paymentMethods[0].isDefault).toBe(true);\n    });\n  });\n\n  describe('Subscription Management', () => {\n    it('should load subscription successfully', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.loadSubscription();\n      });\n\n      expect(result.current.loadingSubscription).toBe(false);\n    });\n\n    it('should create crisis subscription during crisis mode', async () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode\n      await act(async () => {\n        await result.current.enableCrisisMode('subscription_crisis');\n      });\n\n      // Set customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_crisis',\n          userId: 'crisis_user',\n          email: 'crisis@example.com',\n          name: 'Crisis User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.loadSubscription();\n      });\n\n      expect(result.current.activeSubscription).toBeDefined();\n      expect(result.current.activeSubscription?.subscriptionId).toContain('crisis_sub_');\n      expect(result.current.activeSubscription?.status).toBe('active');\n      expect(result.current.activeSubscription?.plan.amount).toBe(0);\n      expect(result.current.activeSubscription?.plan.features).toContain('988 hotline integration');\n    });\n\n    it('should create subscription successfully', async () => {\n      const mockSubscription = {\n        subscriptionId: 'sub_test123',\n        customerId: 'cus_test123',\n        status: 'active' as const,\n        currentPeriodStart: new Date().toISOString(),\n        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n        cancelAtPeriodEnd: false,\n        plan: {\n          planId: 'fullmind_monthly',\n          name: 'FullMind Premium Monthly',\n          description: 'Monthly subscription',\n          amount: 999,\n          currency: 'usd',\n          interval: 'month' as const,\n          features: ['All MBCT practices', 'Progress tracking']\n        }\n      };\n\n      (paymentAPIService.createSubscription as jest.Mock).mockResolvedValue(mockSubscription);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set customer\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test123',\n          userId: 'test_user_123',\n          email: 'test@example.com',\n          name: 'Test User',\n          created: new Date().toISOString()\n        };\n      });\n\n      await act(async () => {\n        await result.current.createSubscription('fullmind_monthly', 'pm_test123', 7);\n      });\n\n      expect(result.current.activeSubscription).toEqual(mockSubscription);\n    });\n\n    it('should cancel subscription successfully', async () => {\n      const mockCanceledSubscription = {\n        subscriptionId: 'sub_test123',\n        customerId: 'cus_test123',\n        status: 'active' as const,\n        currentPeriodStart: new Date().toISOString(),\n        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n        cancelAtPeriodEnd: true,\n        plan: {\n          planId: 'fullmind_monthly',\n          name: 'FullMind Premium Monthly',\n          description: 'Monthly subscription',\n          amount: 999,\n          currency: 'usd',\n          interval: 'month' as const,\n          features: ['All MBCT practices']\n        }\n      };\n\n      (paymentAPIService.cancelSubscription as jest.Mock).mockResolvedValue(mockCanceledSubscription);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set active subscription\n      act(() => {\n        result.current.activeSubscription = {\n          subscriptionId: 'sub_test123',\n          customerId: 'cus_test123',\n          status: 'active',\n          currentPeriodStart: new Date().toISOString(),\n          currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n          cancelAtPeriodEnd: false,\n          plan: {\n            planId: 'fullmind_monthly',\n            name: 'FullMind Premium Monthly',\n            description: 'Monthly subscription',\n            amount: 999,\n            currency: 'usd',\n            interval: 'month',\n            features: ['All MBCT practices']\n          }\n        };\n      });\n\n      await act(async () => {\n        await result.current.cancelSubscription(true);\n      });\n\n      expect(result.current.activeSubscription?.cancelAtPeriodEnd).toBe(true);\n    });\n  });\n\n  describe('Crisis Management', () => {\n    it('should enable crisis mode with proper state transitions', async () => {\n      (paymentAPIService.enableCrisisMode as jest.Mock).mockResolvedValue({\n        crisisSessionId: 'crisis_session_123',\n        userId: 'test_user_123',\n        deviceId: 'test_device_123',\n        overrideReason: 'mental_health_crisis',\n        overrideType: 'full_access',\n        granted: new Date().toISOString(),\n        expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n        auditTrail: {\n          triggerEvent: 'mental_health_crisis',\n          safetyScore: 100,\n          accessGranted: ['all_therapeutic_features', 'crisis_tools', 'emergency_contacts']\n        }\n      });\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.enableCrisisMode('mental_health_crisis');\n      });\n\n      expect(result.current.crisisMode).toBe(true);\n      expect(result.current.crisisOverride).toBeDefined();\n      expect(result.current.crisisOverride?.overrideType).toBe('full_access');\n      expect(result.current.lastPaymentError).toBeNull(); // Errors cleared during crisis\n    });\n\n    it('should handle crisis mode enablement failure with local emergency mode', async () => {\n      (paymentAPIService.enableCrisisMode as jest.Mock).mockRejectedValue(\n        new Error('Crisis API failed')\n      );\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      await act(async () => {\n        await result.current.enableCrisisMode('api_failure_crisis');\n      });\n\n      // Should still enable crisis mode locally\n      expect(result.current.crisisMode).toBe(true);\n      expect(result.current.crisisOverride).toBeDefined();\n      expect(result.current.crisisOverride?.crisisSessionId).toContain('emergency_');\n    });\n\n    it('should disable crisis mode successfully', async () => {\n      (paymentAPIService.disableCrisisMode as jest.Mock).mockResolvedValue(undefined);\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode first\n      act(() => {\n        result.current.crisisMode = true;\n        result.current.crisisOverride = {\n          crisisSessionId: 'test_session',\n          userId: 'test_user',\n          deviceId: 'test_device',\n          overrideReason: 'emergency_access',\n          overrideType: 'full_access',\n          granted: new Date().toISOString(),\n          expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n          auditTrail: {\n            triggerEvent: 'test',\n            safetyScore: 100,\n            accessGranted: ['test']\n          }\n        };\n      });\n\n      await act(async () => {\n        await result.current.disableCrisisMode();\n      });\n\n      expect(result.current.crisisMode).toBe(false);\n      expect(result.current.crisisOverride).toBeNull();\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle payment errors gracefully', () => {\n      const mockError: PaymentError = {\n        type: 'card_error',\n        code: 'card_declined',\n        message: 'Your card was declined.',\n        retryable: true,\n        crisisImpact: 'degraded',\n        userMessage: 'Please try a different payment method.'\n      };\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      act(() => {\n        result.current.handlePaymentError(mockError);\n      });\n\n      expect(result.current.lastPaymentError).toEqual(mockError);\n    });\n\n    it('should provide crisis-aware error handling', () => {\n      const mockError = {\n        type: 'api_error',\n        message: 'Service unavailable'\n      };\n\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Enable crisis mode\n      act(() => {\n        result.current.crisisMode = true;\n      });\n\n      act(() => {\n        result.current.handlePaymentError(mockError);\n      });\n\n      expect(result.current.lastPaymentError?.crisisImpact).toBe('none');\n      expect(result.current.lastPaymentError?.userMessage).toContain('therapeutic features remain accessible');\n    });\n\n    it('should clear payment errors', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set an error first\n      act(() => {\n        result.current.lastPaymentError = {\n          type: 'api_error',\n          code: 'test_error',\n          message: 'Test error',\n          retryable: true,\n          crisisImpact: 'none',\n          userMessage: 'Test error message'\n        };\n      });\n\n      act(() => {\n        result.current.clearPaymentError();\n      });\n\n      expect(result.current.lastPaymentError).toBeNull();\n    });\n  });\n\n  describe('UI State Management', () => {\n    it('should manage payment sheet visibility', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      act(() => {\n        result.current.showPaymentSheet();\n      });\n\n      expect(result.current.showPaymentSheet).toBe(true);\n\n      act(() => {\n        result.current.hidePaymentSheet();\n      });\n\n      expect(result.current.showPaymentSheet).toBe(false);\n    });\n\n    it('should manage subscription selector visibility', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      act(() => {\n        result.current.showSubscriptionSelector();\n      });\n\n      expect(result.current.showSubscriptionSelector).toBe(true);\n\n      act(() => {\n        result.current.hideSubscriptionSelector();\n      });\n\n      expect(result.current.showSubscriptionSelector).toBe(false);\n    });\n  });\n\n  describe('Store Reset and Cleanup', () => {\n    it('should reset store state', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set some state\n      act(() => {\n        result.current.customer = {\n          customerId: 'cus_test',\n          userId: 'user_test',\n          email: 'test@example.com',\n          name: 'Test',\n          created: new Date().toISOString()\n        };\n        result.current.crisisMode = true;\n        result.current.paymentInProgress = true;\n      });\n\n      act(() => {\n        result.current.reset();\n      });\n\n      expect(result.current.customer).toBeNull();\n      expect(result.current.crisisMode).toBe(false);\n      expect(result.current.paymentInProgress).toBe(false);\n    });\n\n    it('should clear sensitive data', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Set sensitive data\n      act(() => {\n        result.current.paymentMethods = [{\n          paymentMethodId: 'pm_sensitive',\n          type: 'card',\n          created: new Date().toISOString(),\n          fingerprint: 'sensitive',\n          metadata: {\n            deviceFingerprint: 'device',\n            riskAssessment: 'low',\n            verificationStatus: 'verified'\n          }\n        }];\n        result.current.currentPaymentIntent = {\n          paymentIntentId: 'pi_sensitive',\n          clientSecret: 'sensitive_secret',\n          status: 'requires_payment_method',\n          amount: 999,\n          currency: 'usd',\n          created: new Date().toISOString()\n        };\n      });\n\n      act(() => {\n        result.current.clearSensitiveData();\n      });\n\n      expect(result.current.paymentMethods).toEqual([]);\n      expect(result.current.currentPaymentIntent).toBeNull();\n    });\n  });\n\n  describe('Selectors', () => {\n    it('should get subscription status with crisis awareness', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // Normal mode\n      act(() => {\n        result.current.activeSubscription = {\n          subscriptionId: 'sub_test',\n          customerId: 'cus_test',\n          status: 'active',\n          currentPeriodStart: new Date().toISOString(),\n          currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n          cancelAtPeriodEnd: false,\n          plan: {\n            planId: 'test_plan',\n            name: 'Test Plan',\n            description: 'Test',\n            amount: 999,\n            currency: 'usd',\n            interval: 'month',\n            features: []\n          }\n        };\n      });\n\n      expect(paymentSelectors.getSubscriptionStatus(result.current)).toBe('active');\n\n      // Crisis mode\n      act(() => {\n        result.current.crisisMode = true;\n      });\n\n      expect(paymentSelectors.getSubscriptionStatus(result.current)).toBe('crisis_access');\n    });\n\n    it('should get feature access with crisis consideration', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      // No subscription - basic access\n      const basicAccess = paymentSelectors.getFeatureAccess(result.current);\n      expect(basicAccess.therapeuticContent).toBe(false);\n      expect(basicAccess.crisisTools).toBe(true); // Always available\n      expect(basicAccess.hotlineAccess).toBe(true); // Always available\n\n      // Crisis mode - full access\n      act(() => {\n        result.current.crisisMode = true;\n      });\n\n      const crisisAccess = paymentSelectors.getFeatureAccess(result.current);\n      expect(crisisAccess.therapeuticContent).toBe(true);\n      expect(crisisAccess.premiumFeatures).toBe(true);\n      expect(crisisAccess.crisisTools).toBe(true);\n    });\n\n    it('should get payment error with crisis awareness', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      const testError: PaymentError = {\n        type: 'api_error',\n        code: 'service_unavailable',\n        message: 'Service unavailable',\n        retryable: true,\n        crisisImpact: 'blocked',\n        userMessage: 'Service temporarily unavailable'\n      };\n\n      act(() => {\n        result.current.lastPaymentError = testError;\n      });\n\n      // Normal mode\n      const normalError = paymentSelectors.getPaymentErrorForUser(result.current);\n      expect(normalError?.crisisImpact).toBe('blocked');\n\n      // Crisis mode\n      act(() => {\n        result.current.crisisMode = true;\n      });\n\n      const crisisError = paymentSelectors.getPaymentErrorForUser(result.current);\n      expect(crisisError?.crisisImpact).toBe('none');\n      expect(crisisError?.userMessage).toContain('therapeutic and safety features remain fully accessible');\n    });\n\n    it('should get performance metrics', () => {\n      const { result } = renderHook(() => usePaymentStore());\n\n      act(() => {\n        result.current.crisisMode = true;\n        result.current.activeSubscription = {\n          subscriptionId: 'sub_test',\n          customerId: 'cus_test',\n          status: 'active',\n          currentPeriodStart: new Date().toISOString(),\n          currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n          cancelAtPeriodEnd: false,\n          plan: {\n            planId: 'test_plan',\n            name: 'Test Plan',\n            description: 'Test',\n            amount: 999,\n            currency: 'usd',\n            interval: 'month',\n            features: []\n          }\n        };\n        result.current.paymentMethods = [\n          {\n            paymentMethodId: 'pm_test',\n            type: 'card',\n            created: new Date().toISOString(),\n            fingerprint: 'test',\n            metadata: {\n              deviceFingerprint: 'device',\n              riskAssessment: 'low',\n              verificationStatus: 'verified'\n            }\n          }\n        ];\n      });\n\n      const metrics = paymentSelectors.getPerformanceMetrics(result.current);\n\n      expect(metrics.crisisModeEnabled).toBe(true);\n      expect(metrics.hasActiveSubscription).toBe(true);\n      expect(metrics.paymentMethodsCount).toBe(1);\n    });\n  });\n\n  describe('Custom Hooks', () => {\n    it('should provide payment actions through usePaymentActions', () => {\n      const { result } = renderHook(() => usePaymentActions());\n\n      expect(typeof result.current.initializePayments).toBe('function');\n      expect(typeof result.current.loadCustomer).toBe('function');\n      expect(typeof result.current.enableCrisisMode).toBe('function');\n      expect(typeof result.current.showPaymentSheet).toBe('function');\n    });\n\n    it('should provide payment status through usePaymentStatus', () => {\n      const { result: storeResult } = renderHook(() => usePaymentStore());\n      const { result: statusResult } = renderHook(() => usePaymentStatus());\n\n      expect(statusResult.current.subscriptionStatus).toBe('none');\n      expect(statusResult.current.featureAccess).toBeDefined();\n      expect(statusResult.current.crisisMode).toBe(false);\n      expect(statusResult.current.isLoading).toBe(false);\n    });\n\n    it('should provide crisis payment safety through useCrisisPaymentSafety', () => {\n      const { result: storeResult } = renderHook(() => usePaymentStore());\n      const { result: crisisResult } = renderHook(() => useCrisisPaymentSafety());\n\n      expect(crisisResult.current.crisisMode).toBe(false);\n      expect(crisisResult.current.crisisOverride).toBeNull();\n      expect(typeof crisisResult.current.enableCrisisMode).toBe('function');\n      expect(typeof crisisResult.current.disableCrisisMode).toBe('function');\n      expect(crisisResult.current.featureAccess).toBeDefined();\n      expect(crisisResult.current.performanceMetrics).toBeDefined();\n    });\n  });\n});",
          "size": 30658,
          "lines": 965,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": true,
          "hasAsyncTests": true,
          "hasExpectations": true
        },
        {
          "path": "src/services/cloud/__tests__/StripePaymentClient.test.ts",
          "exists": true,
          "content": "/**\n * Stripe Payment Client Integration Test Suite\n *\n * Tests HIPAA-compliant Stripe integration with crisis safety protocols\n * Focus Areas:\n * - HIPAA compliance with separate data contexts\n * - Crisis mode bypass functionality\n * - Payment intent and subscription creation\n * - Error handling with graceful degradation\n * - Zero card data storage validation\n */\n\nimport { StripePaymentClient } from '../StripePaymentClient';\nimport { PaymentSecurityService } from '../../security/PaymentSecurityService';\n\n// Mock dependencies\njest.mock('../../security/PaymentSecurityService');\njest.mock('expo-crypto', () => ({\n  getRandomBytesAsync: jest.fn(() => Promise.resolve(new Uint8Array(32).fill(1))),\n  digestStringAsync: jest.fn(() => Promise.resolve('mock_hash'))\n}));\n\ndescribe('StripePaymentClient', () => {\n  let stripeClient: StripePaymentClient;\n  let mockPaymentSecurity: jest.Mocked<PaymentSecurityService>;\n\n  beforeEach(async () => {\n    stripeClient = StripePaymentClient.getInstance();\n    mockPaymentSecurity = PaymentSecurityService.getInstance() as jest.Mocked<PaymentSecurityService>;\n\n    // Mock payment security responses\n    mockPaymentSecurity.initialize.mockResolvedValue();\n    mockPaymentSecurity.createPaymentToken.mockResolvedValue({\n      tokenInfo: {\n        tokenId: 'mock_token_123',\n        paymentMethodType: 'card',\n        last4: '4242',\n        brand: 'visa',\n        expiryMonth: 12,\n        expiryYear: 2025,\n        created: new Date().toISOString(),\n        expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n        metadata: {\n          deviceFingerprint: 'mock_fingerprint',\n          riskAssessment: 'low',\n          verificationStatus: 'verified'\n        }\n      },\n      securityResult: {\n        success: true,\n        action: 'proceed',\n        riskScore: 10,\n        reason: 'Token created successfully',\n        auditEventId: 'audit_123',\n        recommendations: []\n      }\n    });\n\n    mockPaymentSecurity.validatePaymentToken.mockResolvedValue({\n      success: true,\n      action: 'proceed',\n      riskScore: 15,\n      reason: 'Token validated successfully',\n      auditEventId: 'audit_validate_123',\n      recommendations: []\n    });\n\n    // Initialize Stripe client\n    await stripeClient.initialize('pk_test_mock_key');\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Initialization and Configuration', () => {\n    test('should initialize with valid publishable key', async () => {\n      const newClient = StripePaymentClient.getInstance();\n      await expect(newClient.initialize('pk_test_valid_key')).resolves.not.toThrow();\n    });\n\n    test('should reject invalid publishable key', async () => {\n      const newClient = StripePaymentClient.getInstance();\n      await expect(newClient.initialize('invalid_key')).rejects.toThrow('Invalid Stripe publishable key');\n    });\n\n    test('should initialize in crisis mode with reduced timeouts', async () => {\n      const newClient = StripePaymentClient.getInstance();\n      await newClient.initialize('pk_test_crisis_key', true);\n\n      const status = await newClient.getPaymentClientStatus();\n      expect(status.crisisMode).toBe(true);\n    });\n\n    test('should enable emergency mode when initialization fails in crisis', async () => {\n      mockPaymentSecurity.initialize.mockRejectedValueOnce(new Error('Security init failed'));\n\n      // Should not throw during crisis initialization\n      await expect(stripeClient.initialize('pk_test_key', true)).resolves.not.toThrow();\n\n      const status = await stripeClient.getPaymentClientStatus();\n      expect(status.crisisMode).toBe(true);\n    });\n  });\n\n  describe('Payment Intent Operations', () => {\n    test('should create payment intent with HIPAA-compliant metadata', async () => {\n      const paymentData = {\n        amount: 999,\n        currency: 'usd',\n        subscriptionType: 'monthly' as const,\n        description: 'FullMind Premium Monthly',\n        metadata: {\n          userId: 'user_123',\n          deviceId: 'device_456',\n          sessionId: 'session_789',\n          crisisMode: false,\n          appVersion: '1.0.0'\n        }\n      };\n\n      const result = await stripeClient.createPaymentIntent(paymentData);\n\n      expect(result.paymentIntentId).toMatch(/^pi_/);\n      expect(result.clientSecret).toMatch(/^pi_.*_secret/);\n      expect(result.amount).toBe(999);\n      expect(result.currency).toBe('usd');\n      expect(result.status).toBe('requires_payment_method');\n    });\n\n    test('should handle crisis mode payment intent creation', async () => {\n      const paymentData = {\n        amount: 999,\n        currency: 'usd',\n        subscriptionType: 'monthly' as const,\n        description: 'Crisis Access',\n        metadata: {\n          userId: 'crisis_user',\n          deviceId: 'crisis_device',\n          sessionId: 'crisis_session',\n          crisisMode: true,\n          appVersion: '1.0.0'\n        }\n      };\n\n      const startTime = Date.now();\n      const result = await stripeClient.createPaymentIntent(paymentData, true);\n      const responseTime = Date.now() - startTime;\n\n      expect(result.crisisOverride).toBe(true);\n      expect(result.status).toBe('succeeded');\n      expect(result.amount).toBe(0); // Free during crisis\n      expect(responseTime).toBeLessThan(200); // Crisis response time requirement\n    });\n\n    test('should confirm payment intent with security validation', async () => {\n      const result = await stripeClient.confirmPaymentIntent(\n        'pi_test_123',\n        'pm_test_456',\n        'user_123',\n        'device_456'\n      );\n\n      expect(result.paymentIntentId).toBe('pi_test_123');\n      expect(result.status).toBe('succeeded');\n      expect(mockPaymentSecurity.validatePaymentToken).toHaveBeenCalledWith(\n        'pm_test_456',\n        'user_123',\n        'device_456',\n        false\n      );\n    });\n\n    test('should bypass payment confirmation in crisis mode', async () => {\n      const result = await stripeClient.confirmPaymentIntent(\n        'pi_crisis_123',\n        'pm_crisis_456',\n        'crisis_user',\n        'crisis_device',\n        true // Crisis mode\n      );\n\n      expect(result.crisisOverride).toBe(true);\n      expect(result.status).toBe('succeeded');\n      expect(result.clientSecret).toBe('crisis_bypass');\n    });\n  });\n\n  describe('Payment Method Operations', () => {\n    test('should create payment method with card tokenization', async () => {\n      const cardData = {\n        number: '4242424242424242',\n        expiryMonth: 12,\n        expiryYear: 2025,\n        cvc: '123'\n      };\n\n      const billingDetails = {\n        name: 'Test User',\n        email: 'test@example.com'\n      };\n\n      const result = await stripeClient.createPaymentMethod(\n        cardData,\n        billingDetails,\n        'user_123',\n        'device_456'\n      );\n\n      expect(result.paymentMethod.paymentMethodId).toMatch(/^pm_/);\n      expect(result.paymentMethod.type).toBe('card');\n      expect(result.paymentMethod.card?.last4).toBe('4242');\n      expect(result.paymentMethod.card?.brand).toBe('visa');\n\n      // Verify no sensitive card data is returned\n      expect(JSON.stringify(result)).not.toContain('4242424242424242');\n      expect(JSON.stringify(result)).not.toContain('123');\n    });\n\n    test('should handle crisis mode payment method creation', async () => {\n      const billingDetails = {\n        name: 'Crisis User'\n      };\n\n      const result = await stripeClient.createPaymentMethod(\n        {},\n        billingDetails,\n        'crisis_user',\n        'crisis_device',\n        true // Crisis mode\n      );\n\n      expect(result.paymentMethod.paymentMethodId).toMatch(/^crisis_pm_/);\n      expect(result.securityResult.crisisOverride).toBe(true);\n      expect(result.tokenInfo.tokenId).toMatch(/^crisis_/);\n    });\n\n    test('should validate payment method security before creation', async () => {\n      const cardData = {\n        number: '4000000000000002', // Declined card\n        expiryMonth: 1,\n        expiryYear: 2020 // Expired\n      };\n\n      const billingDetails = {\n        name: 'Test User'\n      };\n\n      await stripeClient.createPaymentMethod(\n        cardData,\n        billingDetails,\n        'user_123',\n        'device_456'\n      );\n\n      // Should still call security service for validation\n      expect(mockPaymentSecurity.createPaymentToken).toHaveBeenCalled();\n    });\n  });\n\n  describe('Subscription Management', () => {\n    test('should return available subscription plans', () => {\n      const plans = stripeClient.getSubscriptionPlans();\n\n      expect(plans).toHaveLength(2);\n      expect(plans[0].planId).toBe('fullmind_monthly');\n      expect(plans[1].planId).toBe('fullmind_annual');\n\n      // Verify plan structure\n      const monthlyPlan = plans[0];\n      expect(monthlyPlan.amount).toBe(999);\n      expect(monthlyPlan.currency).toBe('usd');\n      expect(monthlyPlan.interval).toBe('month');\n      expect(monthlyPlan.features).toContain('All MBCT guided practices');\n    });\n\n    test('should create subscription with secure payment method', async () => {\n      const result = await stripeClient.createSubscription(\n        'cus_test_123',\n        'fullmind_monthly',\n        'pm_test_456',\n        'user_123',\n        'device_456',\n        7 // Trial days\n      );\n\n      expect(result.subscriptionId).toMatch(/^sub_/);\n      expect(result.status).toBe('active');\n      expect(result.trialEnd).toBeDefined();\n      expect(mockPaymentSecurity.validatePaymentToken).toHaveBeenCalled();\n    });\n\n    test('should handle crisis mode subscription creation', async () => {\n      const result = await stripeClient.createSubscription(\n        'cus_crisis_123',\n        'fullmind_monthly',\n        'pm_crisis_456',\n        'crisis_user',\n        'crisis_device',\n        undefined, // No trial\n        true // Crisis mode\n      );\n\n      expect(result.subscriptionId).toMatch(/^crisis_sub_/);\n      expect(result.status).toBe('active');\n      // Should not validate payment method in crisis mode\n      expect(mockPaymentSecurity.validatePaymentToken).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Crisis Safety Protocols', () => {\n    test('should maintain <200ms response times in crisis mode', async () => {\n      const iterations = 10;\n      const responseTimes: number[] = [];\n\n      for (let i = 0; i < iterations; i++) {\n        const startTime = Date.now();\n\n        await stripeClient.createPaymentIntent({\n          amount: 999,\n          currency: 'usd',\n          subscriptionType: 'monthly',\n          description: 'Crisis Payment',\n          metadata: {\n            userId: `crisis_user_${i}`,\n            deviceId: `crisis_device_${i}`,\n            sessionId: `crisis_session_${i}`,\n            crisisMode: true,\n            appVersion: '1.0.0'\n          }\n        }, true);\n\n        const responseTime = Date.now() - startTime;\n        responseTimes.push(responseTime);\n      }\n\n      const averageTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;\n      const maxTime = Math.max(...responseTimes);\n\n      expect(averageTime).toBeLessThan(100); // Target <100ms average\n      expect(maxTime).toBeLessThan(200); // Never exceed 200ms\n\n      console.log(`Crisis payment response times - Avg: ${averageTime}ms, Max: ${maxTime}ms`);\n    });\n\n    test('should bypass all payment validation during crisis', async () => {\n      // Mock payment security to fail validation\n      mockPaymentSecurity.validatePaymentToken.mockResolvedValueOnce({\n        success: false,\n        action: 'block',\n        riskScore: 100,\n        reason: 'High risk detected',\n        auditEventId: 'audit_block_123',\n        recommendations: ['Re-authenticate']\n      });\n\n      // Crisis mode should still work\n      const result = await stripeClient.confirmPaymentIntent(\n        'pi_crisis_test',\n        'pm_high_risk',\n        'crisis_user',\n        'crisis_device',\n        true // Crisis mode\n      );\n\n      expect(result.crisisOverride).toBe(true);\n      expect(result.status).toBe('succeeded');\n    });\n\n    test('should preserve 988 hotline access during payment failures', async () => {\n      // Mock all payment operations to fail\n      jest.spyOn(stripeClient, 'createPaymentIntent').mockRejectedValueOnce(\n        new Error('Payment system down')\n      );\n\n      // Crisis mode should provide emergency access\n      const result = await stripeClient.createPaymentIntent({\n        amount: 0,\n        currency: 'usd',\n        subscriptionType: 'monthly',\n        description: 'Emergency Access',\n        metadata: {\n          userId: 'emergency_user',\n          deviceId: 'emergency_device',\n          sessionId: 'emergency_session',\n          crisisMode: true,\n          appVersion: '1.0.0'\n        }\n      }, true);\n\n      expect(result.crisisOverride).toBe(true);\n      expect(result.amount).toBe(0);\n    });\n\n    test('should handle emergency mode when Stripe is unavailable', async () => {\n      // Initialize in crisis mode with Stripe unavailable\n      await stripeClient.initialize('pk_test_unavailable', true);\n\n      const status = await stripeClient.getPaymentClientStatus();\n      expect(status.crisisMode).toBe(true);\n      expect(status.initialized).toBe(true); // Should still initialize\n    });\n  });\n\n  describe('Error Handling and Resilience', () => {\n    test('should format Stripe errors with crisis impact assessment', async () => {\n      // Mock API to throw Stripe error\n      const mockError = {\n        type: 'card_error',\n        code: 'card_declined',\n        message: 'Your card was declined',\n        decline_code: 'generic_decline'\n      };\n\n      // This would be handled internally by formatStripeError\n      // Testing the error structure\n      expect(mockError.type).toBe('card_error');\n      expect(mockError.code).toBe('card_declined');\n    });\n\n    test('should maintain service availability during partial failures', async () => {\n      // Mock payment security to partially fail\n      mockPaymentSecurity.createPaymentToken.mockRejectedValueOnce(\n        new Error('Temporary security failure')\n      );\n\n      // Normal mode should fail\n      await expect(stripeClient.createPaymentMethod(\n        { number: '4242424242424242' },\n        { name: 'Test User' },\n        'user_123',\n        'device_456'\n      )).rejects.toThrow();\n\n      // Crisis mode should still work\n      const crisisResult = await stripeClient.createPaymentMethod(\n        { number: '4242424242424242' },\n        { name: 'Crisis User' },\n        'crisis_user',\n        'crisis_device',\n        true // Crisis mode\n      );\n\n      expect(crisisResult.securityResult.crisisOverride).toBe(true);\n    });\n\n    test('should handle network timeouts gracefully', async () => {\n      // Mock network timeout\n      jest.setTimeout(10000);\n\n      // Crisis operations should complete quickly even with network issues\n      const startTime = Date.now();\n      const result = await stripeClient.createPaymentIntent({\n        amount: 999,\n        currency: 'usd',\n        subscriptionType: 'monthly',\n        description: 'Timeout Test',\n        metadata: {\n          userId: 'timeout_user',\n          deviceId: 'timeout_device',\n          sessionId: 'timeout_session',\n          crisisMode: true,\n          appVersion: '1.0.0'\n        }\n      }, true);\n\n      const responseTime = Date.now() - startTime;\n      expect(responseTime).toBeLessThan(3000); // Crisis timeout limit\n      expect(result.crisisOverride).toBe(true);\n    });\n  });\n\n  describe('HIPAA Compliance', () => {\n    test('should separate payment metadata from health data', async () => {\n      const paymentData = {\n        amount: 999,\n        currency: 'usd',\n        subscriptionType: 'monthly' as const,\n        description: 'FullMind Premium',\n        metadata: {\n          userId: 'hipaa_user',\n          deviceId: 'hipaa_device',\n          sessionId: 'hipaa_session',\n          crisisMode: false,\n          appVersion: '1.0.0'\n        }\n      };\n\n      const result = await stripeClient.createPaymentIntent(paymentData);\n\n      // Verify metadata doesn't contain health information\n      expect(result.paymentIntentId).toBeDefined();\n      expect(JSON.stringify(result)).not.toContain('phq9');\n      expect(JSON.stringify(result)).not.toContain('gad7');\n      expect(JSON.stringify(result)).not.toContain('mood');\n      expect(JSON.stringify(result)).not.toContain('clinical');\n    });\n\n    test('should use separate encryption context for payment data', async () => {\n      await stripeClient.createPaymentMethod(\n        { number: '4242424242424242' },\n        { name: 'HIPAA Test User' },\n        'hipaa_user',\n        'hipaa_device'\n      );\n\n      // Verify payment security uses separate encryption\n      expect(mockPaymentSecurity.createPaymentToken).toHaveBeenCalledWith(\n        expect.objectContaining({\n          type: 'card',\n          last4: '4242'\n        }),\n        'hipaa_user',\n        'hipaa_device',\n        expect.stringMatching(/payment_method_/),\n        false\n      );\n    });\n\n    test('should maintain audit trails separate from health data', async () => {\n      await stripeClient.confirmPaymentIntent(\n        'pi_audit_test',\n        'pm_audit_test',\n        'audit_user',\n        'audit_device'\n      );\n\n      // Payment security should handle audit logging separately\n      expect(mockPaymentSecurity.validatePaymentToken).toHaveBeenCalled();\n      // Audit logs should be in payment security service, not health service\n    });\n  });\n\n  describe('Performance and Monitoring', () => {\n    test('should provide comprehensive status monitoring', async () => {\n      const status = await stripeClient.getPaymentClientStatus();\n\n      expect(status.initialized).toBe(true);\n      expect(status.crisisMode).toBeDefined();\n      expect(status.stripeSDKAvailable).toBeDefined();\n      expect(status.paymentSecurityStatus).toBeDefined();\n      expect(typeof status.averageResponseTime).toBe('number');\n      expect(typeof status.errorRate).toBe('number');\n    });\n\n    test('should handle concurrent payment operations efficiently', async () => {\n      const concurrentOperations = 10;\n      const promises = [];\n\n      for (let i = 0; i < concurrentOperations; i++) {\n        promises.push(\n          stripeClient.createPaymentIntent({\n            amount: 999,\n            currency: 'usd',\n            subscriptionType: 'monthly',\n            description: `Concurrent Test ${i}`,\n            metadata: {\n              userId: `concurrent_user_${i}`,\n              deviceId: `concurrent_device_${i}`,\n              sessionId: `concurrent_session_${i}`,\n              crisisMode: true, // Use crisis mode for consistent performance\n              appVersion: '1.0.0'\n            }\n          }, true)\n        );\n      }\n\n      const results = await Promise.all(promises);\n\n      expect(results).toHaveLength(concurrentOperations);\n      results.forEach(result => {\n        expect(result.crisisOverride).toBe(true);\n        expect(result.status).toBe('succeeded');\n      });\n    });\n  });\n\n  describe('Cleanup and Resource Management', () => {\n    test('should cleanup resources properly', async () => {\n      await expect(stripeClient.cleanup()).resolves.not.toThrow();\n\n      const status = await stripeClient.getPaymentClientStatus();\n      expect(status.initialized).toBe(false);\n      expect(status.crisisMode).toBe(false);\n    });\n\n    test('should handle cleanup during active operations', async () => {\n      // Start payment operation\n      const paymentPromise = stripeClient.createPaymentIntent({\n        amount: 999,\n        currency: 'usd',\n        subscriptionType: 'monthly',\n        description: 'Cleanup Test',\n        metadata: {\n          userId: 'cleanup_user',\n          deviceId: 'cleanup_device',\n          sessionId: 'cleanup_session',\n          crisisMode: true,\n          appVersion: '1.0.0'\n        }\n      }, true);\n\n      // Cleanup should not interfere with active operations\n      await stripeClient.cleanup();\n      const result = await paymentPromise;\n\n      expect(result.crisisOverride).toBe(true);\n    });\n  });\n});",
          "size": 20074,
          "lines": 610,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": true,
          "hasAsyncTests": true,
          "hasExpectations": true
        },
        {
          "path": "__tests__/services/PaymentAPIService.test.ts",
          "exists": true,
          "content": "/**\n * Payment API Service Tests\n *\n * Comprehensive test suite for payment integration including:\n * - Crisis safety payment processing\n * - HIPAA-compliant payment handling\n * - PCI DSS compliance validation\n * - Stripe integration testing\n * - Subscription management testing\n * - Payment security validation\n */\n\nimport { paymentAPIService } from '../../src/services/cloud/PaymentAPIService';\nimport { stripePaymentClient } from '../../src/services/cloud/StripePaymentClient';\nimport { paymentSecurityService } from '../../src/services/security/PaymentSecurityService';\nimport {\n  PaymentConfig,\n  CustomerData,\n  PaymentMethodData,\n  PaymentIntentData,\n  SubscriptionPlan\n} from '../../src/types/payment';\n\n// Mock external dependencies\njest.mock('../../src/services/cloud/StripePaymentClient');\njest.mock('../../src/services/security/PaymentSecurityService');\njest.mock('../../src/services/cloud/CloudSyncAPI');\njest.mock('../../src/services/cloud/AuthIntegrationService');\n\ndescribe('PaymentAPIService', () => {\n  const mockPaymentConfig: PaymentConfig = {\n    stripe: {\n      publishableKey: 'pk_test_mock_key',\n      apiVersion: '2023-10-16',\n      timeout: 30000,\n      maxRetries: 3,\n      enableApplePay: true,\n      enableGooglePay: true\n    },\n    subscription: {\n      defaultTrialDays: 7,\n      gracePeriodDays: 3,\n      retryAttempts: 3,\n      invoiceReminders: true\n    },\n    crisis: {\n      enablePaymentBypass: true,\n      emergencyAccessDuration: 24,\n      crisisDetectionTimeout: 200,\n      hotlineAlwaysAccessible: true\n    },\n    security: {\n      enableFraudDetection: true,\n      rateLimit: {\n        maxAttemptsPerMinute: 10,\n        blockDurationMinutes: 5\n      },\n      tokenExpiry: {\n        paymentMethods: 24,\n        sessions: 2\n      }\n    },\n    compliance: {\n      pciDssLevel: '2',\n      auditRetentionYears: 7,\n      enableDetailedLogging: true,\n      hipaaCompliant: true\n    }\n  };\n\n  const mockCustomerData: CustomerData = {\n    userId: 'test_user_123',\n    email: 'test@example.com',\n    name: 'Test User',\n    metadata: {\n      appUserId: 'test_user_123',\n      deviceId: 'test_device_123',\n      registrationDate: new Date().toISOString(),\n      therapeuticConsent: true,\n      crisisContactConsent: true\n    }\n  };\n\n  const mockPaymentMethodData: PaymentMethodData = {\n    type: 'card',\n    card: {\n      number: '4242424242424242',\n      expiryMonth: 12,\n      expiryYear: 2025,\n      cvc: '123'\n    },\n    billingDetails: {\n      name: 'Test User',\n      email: 'test@example.com'\n    }\n  };\n\n  const mockPaymentIntentData: PaymentIntentData = {\n    amount: 999,\n    currency: 'usd',\n    subscriptionType: 'monthly',\n    description: 'FullMind Premium Monthly Subscription',\n    metadata: {\n      userId: 'test_user_123',\n      deviceId: 'test_device_123',\n      sessionId: 'test_session_123',\n      crisisMode: false,\n      appVersion: '1.0.0'\n    }\n  };\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Reset singleton instance for each test\n    (paymentAPIService as any).initialized = false;\n    (paymentAPIService as any).config = null;\n    (paymentAPIService as any).crisisMode = false;\n  });\n\n  describe('Initialization', () => {\n    it('should initialize payment API service successfully', async () => {\n      // Mock Stripe client initialization\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      (paymentSecurityService.initialize as jest.Mock).mockResolvedValue(undefined);\n\n      await paymentAPIService.initialize(mockPaymentConfig);\n\n      expect(paymentAPIService.isInitialized()).toBe(true);\n      expect(stripePaymentClient.initialize).toHaveBeenCalledWith(\n        mockPaymentConfig.stripe.publishableKey,\n        true // Crisis mode enabled by default\n      );\n    });\n\n    it('should handle initialization failure gracefully with emergency mode', async () => {\n      // Mock initialization failure\n      (stripePaymentClient.initialize as jest.Mock).mockRejectedValue(new Error('Initialization failed'));\n\n      // Should not throw - should enable emergency mode instead\n      await paymentAPIService.initialize(mockPaymentConfig);\n\n      expect(paymentAPIService.isInitialized()).toBe(true);\n    });\n\n    it('should validate payment configuration schema', async () => {\n      const invalidConfig = { ...mockPaymentConfig, stripe: null };\n\n      await expect(paymentAPIService.initialize(invalidConfig as any))\n        .rejects.toThrow();\n    });\n  });\n\n  describe('Customer Management', () => {\n    beforeEach(async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n    });\n\n    it('should create customer successfully', async () => {\n      const mockCustomerResult = {\n        customerId: 'cus_test123',\n        userId: mockCustomerData.userId,\n        email: mockCustomerData.email,\n        name: mockCustomerData.name,\n        created: new Date().toISOString()\n      };\n\n      const customer = await paymentAPIService.createCustomer(mockCustomerData);\n\n      expect(customer).toMatchObject({\n        userId: mockCustomerData.userId,\n        email: mockCustomerData.email,\n        name: mockCustomerData.name\n      });\n      expect(customer.customerId).toBeDefined();\n      expect(customer.created).toBeDefined();\n    });\n\n    it('should handle customer creation during crisis mode', async () => {\n      // Enable crisis mode\n      await paymentAPIService.enableCrisisMode('test_user_123', 'test_device_123', 'test_crisis');\n\n      const customer = await paymentAPIService.createCustomer(mockCustomerData);\n\n      expect(customer.customerId).toContain('crisis_');\n      expect(customer.userId).toBe(mockCustomerData.userId);\n    });\n\n    it('should retrieve existing customer', async () => {\n      const customerId = 'cus_existing123';\n\n      const customer = await paymentAPIService.getCustomer(customerId);\n\n      // Should attempt to get from cache first, then from Stripe\n      expect(customer).toBeDefined();\n    });\n\n    it('should update customer information', async () => {\n      const customerId = 'cus_test123';\n      const updates = { name: 'Updated Name' };\n\n      // Create mock existing customer\n      const existingCustomer = {\n        customerId,\n        userId: 'test_user_123',\n        email: 'test@example.com',\n        name: 'Original Name',\n        created: new Date().toISOString()\n      };\n\n      const updatedCustomer = await paymentAPIService.updateCustomer(customerId, updates);\n\n      expect(updatedCustomer).toMatchObject(updates);\n    });\n  });\n\n  describe('Payment Method Management', () => {\n    beforeEach(async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n    });\n\n    it('should create payment method successfully', async () => {\n      const customerId = 'cus_test123';\n\n      // Mock Stripe client payment method creation\n      (stripePaymentClient.createPaymentMethod as jest.Mock).mockResolvedValue({\n        paymentMethod: {\n          paymentMethodId: 'pm_test123',\n          type: 'card',\n          card: {\n            brand: 'visa',\n            last4: '4242',\n            expiryMonth: 12,\n            expiryYear: 2025\n          },\n          created: new Date().toISOString(),\n          fingerprint: 'test_fingerprint'\n        }\n      });\n\n      const paymentMethod = await paymentAPIService.createPaymentMethod(\n        mockPaymentMethodData,\n        customerId\n      );\n\n      expect(paymentMethod.paymentMethodId).toBe('pm_test123');\n      expect(paymentMethod.type).toBe('card');\n      expect(paymentMethod.card?.last4).toBe('4242');\n    });\n\n    it('should handle payment method creation during crisis mode', async () => {\n      const customerId = 'cus_test123';\n\n      // Enable crisis mode\n      await paymentAPIService.enableCrisisMode('test_user_123', 'test_device_123', 'emergency_access');\n\n      const paymentMethod = await paymentAPIService.createPaymentMethod(\n        mockPaymentMethodData,\n        customerId,\n        true // Crisis mode\n      );\n\n      expect(paymentMethod.paymentMethodId).toContain('crisis_pm_');\n      expect(paymentMethod.card?.last4).toBe('0000');\n    });\n\n    it('should list payment methods for customer', async () => {\n      const customerId = 'cus_test123';\n\n      const paymentMethods = await paymentAPIService.listPaymentMethods(customerId);\n\n      expect(Array.isArray(paymentMethods)).toBe(true);\n    });\n\n    it('should delete payment method', async () => {\n      const paymentMethodId = 'pm_test123';\n\n      await expect(paymentAPIService.deletePaymentMethod(paymentMethodId))\n        .resolves.not.toThrow();\n    });\n\n    it('should set default payment method', async () => {\n      const customerId = 'cus_test123';\n      const paymentMethodId = 'pm_test123';\n\n      await expect(paymentAPIService.setDefaultPaymentMethod(customerId, paymentMethodId))\n        .resolves.not.toThrow();\n    });\n  });\n\n  describe('Payment Intent Management', () => {\n    beforeEach(async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n    });\n\n    it('should create payment intent successfully', async () => {\n      // Mock Stripe client payment intent creation\n      (stripePaymentClient.createPaymentIntent as jest.Mock).mockResolvedValue({\n        paymentIntentId: 'pi_test123',\n        clientSecret: 'pi_test123_secret',\n        status: 'requires_payment_method',\n        amount: 999,\n        currency: 'usd',\n        created: new Date().toISOString()\n      });\n\n      const paymentIntent = await paymentAPIService.createPaymentIntent(mockPaymentIntentData);\n\n      expect(paymentIntent.paymentIntentId).toBe('pi_test123');\n      expect(paymentIntent.amount).toBe(999);\n      expect(paymentIntent.currency).toBe('usd');\n    });\n\n    it('should handle payment intent creation during crisis with <200ms response', async () => {\n      // Enable crisis mode\n      await paymentAPIService.enableCrisisMode('test_user_123', 'test_device_123', 'crisis_access');\n\n      const startTime = Date.now();\n      const paymentIntent = await paymentAPIService.createPaymentIntent(\n        mockPaymentIntentData,\n        true // Crisis mode\n      );\n      const responseTime = Date.now() - startTime;\n\n      expect(responseTime).toBeLessThan(200); // Must maintain <200ms for crisis\n      expect(paymentIntent.paymentIntentId).toContain('crisis_intent_');\n      expect(paymentIntent.amount).toBe(0); // Free during crisis\n      expect(paymentIntent.crisisOverride).toBe(true);\n    });\n\n    it('should confirm payment intent', async () => {\n      const paymentIntentId = 'pi_test123';\n      const paymentMethodId = 'pm_test123';\n\n      // Mock Stripe client confirmation\n      (stripePaymentClient.confirmPaymentIntent as jest.Mock).mockResolvedValue({\n        paymentIntentId,\n        clientSecret: 'pi_test123_secret',\n        status: 'succeeded',\n        amount: 999,\n        currency: 'usd',\n        created: new Date().toISOString()\n      });\n\n      const confirmedIntent = await paymentAPIService.confirmPaymentIntent(\n        paymentIntentId,\n        paymentMethodId\n      );\n\n      expect(confirmedIntent.status).toBe('succeeded');\n    });\n\n    it('should retrieve payment intent', async () => {\n      const paymentIntentId = 'pi_test123';\n\n      const paymentIntent = await paymentAPIService.getPaymentIntent(paymentIntentId);\n\n      expect(paymentIntent).toBeDefined();\n    });\n  });\n\n  describe('Subscription Management', () => {\n    beforeEach(async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n    });\n\n    it('should create subscription successfully', async () => {\n      const customerId = 'cus_test123';\n      const planId = 'fullmind_monthly';\n      const paymentMethodId = 'pm_test123';\n\n      // Mock Stripe client subscription creation\n      (stripePaymentClient.createSubscription as jest.Mock).mockResolvedValue({\n        subscriptionId: 'sub_test123',\n        status: 'active',\n        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()\n      });\n\n      const subscription = await paymentAPIService.createSubscription(\n        customerId,\n        planId,\n        paymentMethodId,\n        7 // Trial days\n      );\n\n      expect(subscription.subscriptionId).toBe('sub_test123');\n      expect(subscription.status).toBe('active');\n    });\n\n    it('should create crisis subscription for therapeutic continuity', async () => {\n      const customerId = 'cus_test123';\n      const planId = 'fullmind_monthly';\n\n      // Enable crisis mode\n      await paymentAPIService.enableCrisisMode('test_user_123', 'test_device_123', 'therapeutic_continuity');\n\n      const subscription = await paymentAPIService.createSubscription(\n        customerId,\n        planId,\n        undefined, // No payment method needed\n        undefined, // No trial\n        true // Crisis mode\n      );\n\n      expect(subscription.subscriptionId).toContain('crisis_sub_');\n      expect(subscription.status).toBe('active');\n      expect(subscription.plan.amount).toBe(0); // Free during crisis\n    });\n\n    it('should get subscription details', async () => {\n      const subscriptionId = 'sub_test123';\n\n      const subscription = await paymentAPIService.getSubscription(subscriptionId);\n\n      expect(subscription).toBeDefined();\n    });\n\n    it('should update subscription', async () => {\n      const subscriptionId = 'sub_test123';\n      const updates = { cancelAtPeriodEnd: true };\n\n      const updatedSubscription = await paymentAPIService.updateSubscription(\n        subscriptionId,\n        updates\n      );\n\n      expect(updatedSubscription).toMatchObject(updates);\n    });\n\n    it('should cancel subscription', async () => {\n      const subscriptionId = 'sub_test123';\n\n      const canceledSubscription = await paymentAPIService.cancelSubscription(\n        subscriptionId,\n        true // At period end\n      );\n\n      expect(canceledSubscription.cancelAtPeriodEnd).toBe(true);\n    });\n\n    it('should reactivate subscription', async () => {\n      const subscriptionId = 'sub_test123';\n\n      const reactivatedSubscription = await paymentAPIService.reactivateSubscription(\n        subscriptionId\n      );\n\n      expect(reactivatedSubscription.status).toBe('active');\n    });\n  });\n\n  describe('Crisis Management', () => {\n    beforeEach(async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n    });\n\n    it('should enable crisis mode with <200ms response time', async () => {\n      const userId = 'test_user_123';\n      const deviceId = 'test_device_123';\n      const reason = 'mental_health_crisis';\n\n      const startTime = Date.now();\n      const crisisOverride = await paymentAPIService.enableCrisisMode(userId, deviceId, reason);\n      const responseTime = Date.now() - startTime;\n\n      expect(responseTime).toBeLessThan(200); // Critical performance requirement\n      expect(crisisOverride.crisisSessionId).toBeDefined();\n      expect(crisisOverride.userId).toBe(userId);\n      expect(crisisOverride.overrideType).toBe('full_access');\n      expect(crisisOverride.auditTrail.safetyScore).toBe(100);\n    });\n\n    it('should provide full therapeutic access during crisis', async () => {\n      const userId = 'test_user_123';\n      const deviceId = 'test_device_123';\n\n      const crisisOverride = await paymentAPIService.enableCrisisMode(\n        userId,\n        deviceId,\n        'suicide_ideation'\n      );\n\n      expect(crisisOverride.auditTrail.accessGranted).toContain('therapeutic_content');\n      expect(crisisOverride.auditTrail.accessGranted).toContain('crisis_tools');\n      expect(crisisOverride.auditTrail.accessGranted).toContain('emergency_contacts');\n      expect(crisisOverride.auditTrail.accessGranted).toContain('988_hotline');\n    });\n\n    it('should disable crisis mode successfully', async () => {\n      const userId = 'test_user_123';\n      const deviceId = 'test_device_123';\n\n      // Enable crisis mode first\n      const crisisOverride = await paymentAPIService.enableCrisisMode(\n        userId,\n        deviceId,\n        'test_crisis'\n      );\n\n      // Disable crisis mode\n      await paymentAPIService.disableCrisisMode(crisisOverride.crisisSessionId);\n\n      // Should not throw and crisis mode should be disabled\n      expect(true).toBe(true); // Test passes if no exception thrown\n    });\n\n    it('should get crisis status for user', async () => {\n      const userId = 'test_user_123';\n      const deviceId = 'test_device_123';\n\n      // Enable crisis mode first\n      await paymentAPIService.enableCrisisMode(userId, deviceId, 'test_crisis');\n\n      const crisisStatus = await paymentAPIService.getCrisisStatus(userId);\n\n      expect(crisisStatus).toBeDefined();\n      expect(crisisStatus?.userId).toBe(userId);\n    });\n\n    it('should maintain 988 hotline access even during payment failures', async () => {\n      // Simulate payment system failure\n      (stripePaymentClient.createPaymentIntent as jest.Mock).mockRejectedValue(\n        new Error('Payment system unavailable')\n      );\n\n      // Enable crisis mode\n      const crisisOverride = await paymentAPIService.enableCrisisMode(\n        'test_user_123',\n        'test_device_123',\n        'payment_system_failure'\n      );\n\n      // Verify 988 access is guaranteed\n      expect(crisisOverride.auditTrail.accessGranted).toContain('988_hotline');\n      expect(crisisOverride.overrideType).toBe('full_access');\n    });\n  });\n\n  describe('Utility Methods', () => {\n    beforeEach(async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n    });\n\n    it('should get available subscription plans', async () => {\n      const mockPlans: SubscriptionPlan[] = [\n        {\n          planId: 'fullmind_monthly',\n          name: 'FullMind Premium Monthly',\n          description: 'Monthly subscription',\n          amount: 999,\n          currency: 'usd',\n          interval: 'month',\n          features: ['All MBCT practices', 'Progress tracking']\n        }\n      ];\n\n      (stripePaymentClient.getSubscriptionPlans as jest.Mock).mockReturnValue(mockPlans);\n\n      const plans = await paymentAPIService.getAvailablePlans();\n\n      expect(plans).toEqual(mockPlans);\n      expect(plans[0].planId).toBe('fullmind_monthly');\n    });\n\n    it('should validate payment method', async () => {\n      const paymentMethodId = 'pm_test123';\n\n      // Mock successful validation\n      (stripePaymentClient as any).paymentSecurity = {\n        validatePaymentToken: jest.fn().mockResolvedValue({ success: true })\n      };\n\n      const isValid = await paymentAPIService.validatePaymentMethod(paymentMethodId);\n\n      expect(isValid).toBe(true);\n    });\n\n    it('should get payment history', async () => {\n      const customerId = 'cus_test123';\n      const limit = 10;\n\n      const history = await paymentAPIService.getPaymentHistory(customerId, limit);\n\n      expect(Array.isArray(history)).toBe(true);\n    });\n  });\n\n  describe('Health and Status Monitoring', () => {\n    beforeEach(async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n    });\n\n    it('should return health status', async () => {\n      // Mock Stripe client status\n      (stripePaymentClient.getPaymentClientStatus as jest.Mock).mockResolvedValue({\n        initialized: true,\n        stripeSDKAvailable: true,\n        errorRate: 0\n      });\n\n      const healthStatus = await paymentAPIService.getHealthStatus();\n\n      expect(healthStatus.stripe.connected).toBe(true);\n      expect(healthStatus.database.connected).toBeDefined();\n      expect(healthStatus.crisisMode).toBeDefined();\n      expect(Array.isArray(healthStatus.errors)).toBe(true);\n    });\n\n    it('should report errors in health status', async () => {\n      // Mock Stripe connection failure\n      (stripePaymentClient.getPaymentClientStatus as jest.Mock).mockResolvedValue({\n        initialized: false,\n        stripeSDKAvailable: false,\n        errorRate: 100\n      });\n\n      const healthStatus = await paymentAPIService.getHealthStatus();\n\n      expect(healthStatus.stripe.connected).toBe(false);\n      expect(healthStatus.errors.length).toBeGreaterThan(0);\n    });\n\n    it('should handle health check failures gracefully', async () => {\n      // Mock health check failure\n      (stripePaymentClient.getPaymentClientStatus as jest.Mock).mockRejectedValue(\n        new Error('Health check failed')\n      );\n\n      const healthStatus = await paymentAPIService.getHealthStatus();\n\n      expect(healthStatus.stripe.connected).toBe(false);\n      expect(healthStatus.errors).toContain('Health status check failed');\n    });\n  });\n\n  describe('Error Handling', () => {\n    beforeEach(async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n    });\n\n    it('should format payment errors with user-friendly messages', async () => {\n      const error = {\n        type: 'card_error',\n        code: 'card_declined',\n        message: 'Your card was declined.'\n      };\n\n      // This tests the private method indirectly through public API\n      try {\n        (stripePaymentClient.createPaymentIntent as jest.Mock).mockRejectedValue(error);\n        await paymentAPIService.createPaymentIntent(mockPaymentIntentData);\n      } catch (formattedError: any) {\n        expect(formattedError.userMessage).toContain('payment method');\n        expect(formattedError.suggestions).toBeDefined();\n      }\n    });\n\n    it('should assess crisis impact of payment errors', async () => {\n      const criticalError = {\n        type: 'api_error',\n        code: 'service_unavailable',\n        message: 'Service temporarily unavailable'\n      };\n\n      try {\n        (stripePaymentClient.createPaymentIntent as jest.Mock).mockRejectedValue(criticalError);\n        await paymentAPIService.createPaymentIntent(mockPaymentIntentData);\n      } catch (formattedError: any) {\n        expect(['degraded', 'blocked']).toContain(formattedError.crisisImpact);\n      }\n    });\n\n    it('should provide crisis-aware error messages', async () => {\n      // Enable crisis mode\n      await paymentAPIService.enableCrisisMode('test_user_123', 'test_device_123', 'error_test');\n\n      const error = {\n        type: 'api_error',\n        message: 'Payment service unavailable'\n      };\n\n      try {\n        (stripePaymentClient.createPaymentIntent as jest.Mock).mockRejectedValue(error);\n        await paymentAPIService.createPaymentIntent(mockPaymentIntentData, true);\n      } catch (formattedError: any) {\n        expect(formattedError.userMessage).toContain('therapeutic features remain accessible');\n        expect(formattedError.crisisImpact).toBe('none');\n      }\n    });\n  });\n\n  describe('Performance Requirements', () => {\n    beforeEach(async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n    });\n\n    it('should maintain crisis response time under 200ms', async () => {\n      const iterations = 10;\n      const responseTimes: number[] = [];\n\n      for (let i = 0; i < iterations; i++) {\n        const startTime = Date.now();\n        await paymentAPIService.enableCrisisMode(\n          `test_user_${i}`,\n          `test_device_${i}`,\n          'performance_test'\n        );\n        const responseTime = Date.now() - startTime;\n        responseTimes.push(responseTime);\n      }\n\n      const averageResponseTime = responseTimes.reduce((a, b) => a + b) / responseTimes.length;\n      const maxResponseTime = Math.max(...responseTimes);\n\n      expect(averageResponseTime).toBeLessThan(200);\n      expect(maxResponseTime).toBeLessThan(200);\n    });\n\n    it('should handle payment processing within acceptable time limits', async () => {\n      (stripePaymentClient.createPaymentIntent as jest.Mock).mockImplementation(\n        () => new Promise(resolve => {\n          setTimeout(() => resolve({\n            paymentIntentId: 'pi_test123',\n            clientSecret: 'secret',\n            status: 'requires_payment_method',\n            amount: 999,\n            currency: 'usd',\n            created: new Date().toISOString()\n          }), 100); // Simulate 100ms processing time\n        })\n      );\n\n      const startTime = Date.now();\n      await paymentAPIService.createPaymentIntent(mockPaymentIntentData);\n      const processingTime = Date.now() - startTime;\n\n      expect(processingTime).toBeLessThan(5000); // Should be under 5 seconds\n    });\n  });\n\n  describe('Integration Tests', () => {\n    it('should integrate with existing cloud sync API', async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n\n      // Test should verify integration without mocking everything\n      expect(paymentAPIService.isInitialized()).toBe(true);\n    });\n\n    it('should integrate with auth service for user context', async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n\n      // This tests the auth integration indirectly\n      const customer = await paymentAPIService.createCustomer(mockCustomerData);\n      expect(customer).toBeDefined();\n    });\n\n    it('should integrate with encryption service for data protection', async () => {\n      (stripePaymentClient.initialize as jest.Mock).mockResolvedValue(undefined);\n      await paymentAPIService.initialize(mockPaymentConfig);\n\n      // This tests encryption integration through secure storage\n      const customer = await paymentAPIService.createCustomer(mockCustomerData);\n      expect(customer.customerId).toBeDefined(); // Stored with encryption\n    });\n  });\n});",
          "size": 26181,
          "lines": 777,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": true,
          "hasAsyncTests": true,
          "hasExpectations": true
        }
      ],
      "totalFiles": 3,
      "existingFiles": 3,
      "totalLines": 2352,
      "hasTests": 3,
      "requirements": [
        "End-to-end subscription flow (trial â†’ paid)",
        "Payment method management (CRUD operations)",
        "Stripe Elements integration with error handling",
        "Subscription tier changes and cancellations",
        "Payment failure recovery with therapeutic messaging"
      ],
      "coverage": 100
    },
    "performance": {
      "name": "Performance Testing",
      "icon": "âš¡",
      "files": [
        {
          "path": "__tests__/performance/critical-timing.test.ts",
          "exists": true,
          "content": "/**\n * Performance Tests - Critical Timing Requirements\n * \n * Validates performance requirements for mental health app:\n * - Crisis button: <200ms response\n * - App launch: <3 seconds \n * - Breathing animations: 60fps sustained\n * - Assessment loading: <300ms\n */\n\nimport { useAssessmentStore } from '../../src/store/assessmentStore';\nimport { useCheckInStore } from '../../src/store/checkInStore';\nimport { dataStore } from '../../src/services/storage/DataStore';\n\n// Mock performance measurement\nconst mockPerformanceMeasurement = () => {\n  const marks: { [key: string]: number } = {};\n  \n  return {\n    mark: (name: string) => {\n      marks[name] = performance.now();\n    },\n    measure: (name: string, startMark: string, endMark: string) => {\n      return marks[endMark] - marks[startMark];\n    }\n  };\n};\n\ndescribe('Performance: Critical Timing Requirements', () => {\n  let performanceTracker: ReturnType<typeof mockPerformanceMeasurement>;\n\n  beforeEach(() => {\n    performanceTracker = mockPerformanceMeasurement();\n  });\n\n  describe('Crisis Button Response Time (<200ms)', () => {\n    test('Crisis button accessibility from any screen', async () => {\n      performanceTracker.mark('crisis-start');\n      \n      // Simulate crisis button press from home screen\n      const crisisButtonHandler = jest.fn(() => {\n        // Simulate navigation to crisis screen\n        return Promise.resolve();\n      });\n\n      performanceTracker.mark('crisis-navigation-start');\n      await crisisButtonHandler();\n      performanceTracker.mark('crisis-navigation-end');\n\n      const responseTime = performanceTracker.measure(\n        'crisis-response',\n        'crisis-navigation-start',\n        'crisis-navigation-end'\n      );\n\n      // Crisis button must respond in under 200ms\n      expect(responseTime).toBeLessThan(200);\n    });\n\n    test('Crisis detection speed in assessment', async () => {\n      const store = useAssessmentStore.getState();\n      \n      // Simulate crisis-level assessment\n      store.startAssessment('phq9', 'standalone');\n      \n      performanceTracker.mark('crisis-detection-start');\n      \n      // Answer questions leading to crisis\n      const crisisAnswers = [3, 3, 3, 3, 3, 3, 2, 1, 1]; // Score: 22\n      crisisAnswers.forEach((answer, index) => {\n        store.answerQuestion(answer);\n      });\n      \n      // Calculate crisis detection time\n      const score = store.calculateScore('phq9', crisisAnswers);\n      const needsCrisis = score >= 20;\n      \n      performanceTracker.mark('crisis-detection-end');\n      \n      const detectionTime = performanceTracker.measure(\n        'crisis-detection',\n        'crisis-detection-start', \n        'crisis-detection-end'\n      );\n\n      expect(needsCrisis).toBe(true);\n      expect(detectionTime).toBeLessThan(50); // Crisis detection should be near-instant\n    });\n\n    test('Emergency calling functionality speed', async () => {\n      // Mock Linking.openURL for performance testing\n      const mockOpenURL = jest.fn().mockResolvedValue(true);\n      require('react-native').Linking = {\n        canOpenURL: jest.fn().mockResolvedValue(true),\n        openURL: mockOpenURL\n      };\n\n      performanceTracker.mark('call-start');\n      \n      // Simulate 988 call initiation\n      const phoneURL = 'tel:988';\n      await mockOpenURL(phoneURL);\n      \n      performanceTracker.mark('call-end');\n      \n      const callInitiationTime = performanceTracker.measure(\n        'call-initiation',\n        'call-start',\n        'call-end'\n      );\n\n      // Call initiation should be immediate\n      expect(callInitiationTime).toBeLessThan(100);\n      expect(mockOpenURL).toHaveBeenCalledWith('tel:988');\n    });\n  });\n\n  describe('App Launch Performance (<3 seconds)', () => {\n    test('Cold start time to home screen', async () => {\n      performanceTracker.mark('app-start');\n      \n      // Simulate app initialization\n      const stores = [\n        useAssessmentStore.getState(),\n        useCheckInStore.getState()\n      ];\n\n      // Load initial data\n      performanceTracker.mark('data-load-start');\n      await Promise.all([\n        stores[0].loadAssessments(),\n        stores[1].loadCheckIns()\n      ]);\n      performanceTracker.mark('data-load-end');\n\n      // Simulate home screen render\n      performanceTracker.mark('render-start');\n      // Mock component render time\n      await new Promise(resolve => setTimeout(resolve, 50));\n      performanceTracker.mark('render-end');\n\n      performanceTracker.mark('app-ready');\n\n      const totalLaunchTime = performanceTracker.measure(\n        'app-launch',\n        'app-start',\n        'app-ready'\n      );\n\n      const dataLoadTime = performanceTracker.measure(\n        'data-load',\n        'data-load-start',\n        'data-load-end'\n      );\n\n      const renderTime = performanceTracker.measure(\n        'render',\n        'render-start',\n        'render-end'\n      );\n\n      // Total launch time must be under 3 seconds\n      expect(totalLaunchTime).toBeLessThan(3000);\n      \n      // Data loading should be reasonable\n      expect(dataLoadTime).toBeLessThan(1000);\n      \n      // Initial render should be fast\n      expect(renderTime).toBeLessThan(500);\n    });\n\n    test('Partial session recovery speed', async () => {\n      const checkInStore = useCheckInStore.getState();\n\n      // Create partial session\n      const partialSession = {\n        id: 'partial_test',\n        type: 'morning' as const,\n        startedAt: new Date().toISOString(),\n        data: {\n          sleepQuality: 7,\n          energyLevel: 6\n        }\n      };\n\n      await dataStore.savePartialCheckIn(partialSession);\n\n      performanceTracker.mark('recovery-start');\n      \n      // Resume partial session\n      const recovered = await checkInStore.resumeCheckIn('morning');\n      \n      performanceTracker.mark('recovery-end');\n\n      const recoveryTime = performanceTracker.measure(\n        'session-recovery',\n        'recovery-start',\n        'recovery-end'\n      );\n\n      expect(recovered).toBe(true);\n      expect(recoveryTime).toBeLessThan(500);\n    });\n  });\n\n  describe('Assessment Loading Performance (<300ms)', () => {\n    test('PHQ-9 assessment initialization', async () => {\n      const store = useAssessmentStore.getState();\n      \n      performanceTracker.mark('assessment-start');\n      \n      // Initialize PHQ-9 assessment\n      store.startAssessment('phq9', 'standalone');\n      \n      performanceTracker.mark('assessment-ready');\n\n      const initTime = performanceTracker.measure(\n        'assessment-init',\n        'assessment-start',\n        'assessment-ready'\n      );\n\n      expect(store.currentAssessment).not.toBeNull();\n      expect(store.currentAssessment!.config!.type).toBe('phq9');\n      expect(initTime).toBeLessThan(300);\n    });\n\n    test('Assessment question navigation speed', async () => {\n      const store = useAssessmentStore.getState();\n      store.startAssessment('gad7', 'standalone');\n\n      const navigationTimes: number[] = [];\n\n      // Test navigation through all questions\n      for (let i = 0; i < 7; i++) {\n        performanceTracker.mark(`question-${i}-start`);\n        \n        store.answerQuestion(2);\n        \n        performanceTracker.mark(`question-${i}-end`);\n        \n        const navTime = performanceTracker.measure(\n          `question-${i}`,\n          `question-${i}-start`,\n          `question-${i}-end`\n        );\n        \n        navigationTimes.push(navTime);\n      }\n\n      // Each question navigation should be fast\n      navigationTimes.forEach((time, index) => {\n        expect(time).toBeLessThan(100); // 100ms per question max\n      });\n\n      // Average navigation time should be very fast\n      const averageTime = navigationTimes.reduce((sum, time) => sum + time, 0) / navigationTimes.length;\n      expect(averageTime).toBeLessThan(50);\n    });\n\n    test('Assessment saving performance', async () => {\n      const store = useAssessmentStore.getState();\n      store.startAssessment('phq9', 'standalone');\n\n      // Complete assessment\n      for (let i = 0; i < 9; i++) {\n        store.answerQuestion(1);\n      }\n\n      performanceTracker.mark('save-start');\n      \n      await store.saveAssessment();\n      \n      performanceTracker.mark('save-end');\n\n      const saveTime = performanceTracker.measure(\n        'assessment-save',\n        'save-start',\n        'save-end'\n      );\n\n      expect(saveTime).toBeLessThan(1000); // Save within 1 second\n    });\n  });\n\n  describe('Breathing Animation Performance (60fps)', () => {\n    test('Breathing circle animation frame rate', async () => {\n      const TARGET_FPS = 60;\n      const FRAME_TIME_MS = 1000 / TARGET_FPS; // ~16.67ms per frame\n      const TEST_DURATION = 1000; // Test for 1 second\n      \n      const frameData: number[] = [];\n      let lastFrameTime = performance.now();\n\n      // Simulate breathing animation loop\n      const animationFrames = Math.floor(TEST_DURATION / FRAME_TIME_MS);\n      \n      for (let frame = 0; frame < animationFrames; frame++) {\n        const currentTime = performance.now();\n        const frameDelta = currentTime - lastFrameTime;\n        frameData.push(frameDelta);\n        lastFrameTime = currentTime;\n        \n        // Simulate animation work (breathing circle scaling)\n        const progress = frame / animationFrames;\n        const scale = 1 + Math.sin(progress * Math.PI * 2) * 0.2;\n        \n        // Mock animation calculation overhead\n        Math.sin(scale * progress);\n      }\n\n      // Calculate frame rate statistics\n      const averageFrameTime = frameData.reduce((sum, time) => sum + time, 0) / frameData.length;\n      const actualFPS = 1000 / averageFrameTime;\n      \n      // Count dropped frames (frames taking longer than 16.67ms)\n      const droppedFrames = frameData.filter(time => time > FRAME_TIME_MS * 1.5).length;\n      const droppedFramePercentage = (droppedFrames / frameData.length) * 100;\n\n      // Performance requirements for breathing animation\n      expect(actualFPS).toBeGreaterThanOrEqual(50); // Allow some tolerance\n      expect(droppedFramePercentage).toBeLessThan(5); // <5% dropped frames\n      expect(averageFrameTime).toBeLessThan(20); // Average frame time under 20ms\n    });\n\n    test('3-minute breathing session memory stability', async () => {\n      const SESSION_DURATION = 180; // 3 minutes in seconds  \n      const FRAME_RATE = 60;\n      const TOTAL_FRAMES = SESSION_DURATION * FRAME_RATE;\n      \n      let memoryUsage = 0; // Mock memory tracking\n      const memorySnapshots: number[] = [];\n\n      // Simulate 3-minute breathing session\n      for (let frame = 0; frame < TOTAL_FRAMES; frame++) {\n        // Mock animation calculations\n        const progress = (frame / TOTAL_FRAMES) * Math.PI * 2;\n        const breathPhase = Math.sin(progress / 20); // 20-second breath cycle\n        const scale = 1 + breathPhase * 0.3;\n        \n        // Simulate memory usage (objects creation/cleanup)\n        memoryUsage += 1;\n        if (frame % 60 === 0) { // Cleanup every second\n          memoryUsage = Math.max(0, memoryUsage - 30);\n          memorySnapshots.push(memoryUsage);\n        }\n      }\n\n      // Memory should remain stable (no continuous growth)\n      const startMemory = memorySnapshots[0];\n      const endMemory = memorySnapshots[memorySnapshots.length - 1];\n      const memoryGrowthRatio = endMemory / startMemory;\n\n      expect(memoryGrowthRatio).toBeLessThan(1.5); // Memory shouldn't grow more than 50%\n    });\n  });\n\n  describe('Check-in Flow Performance', () => {\n    test('Check-in transition times (<500ms)', async () => {\n      const store = useCheckInStore.getState();\n      \n      performanceTracker.mark('checkin-start');\n      \n      store.startCheckIn('morning');\n      \n      performanceTracker.mark('checkin-init');\n      \n      // Simulate step transitions\n      const transitionTimes: number[] = [];\n      \n      for (let step = 0; step < 5; step++) {\n        performanceTracker.mark(`step-${step}-start`);\n        \n        // Update check-in data (simulating screen transition)\n        store.updateCurrentCheckIn({ \n          sleepQuality: 7,\n          energyLevel: step + 5\n        });\n        \n        performanceTracker.mark(`step-${step}-end`);\n        \n        const stepTime = performanceTracker.measure(\n          `step-${step}`,\n          `step-${step}-start`,\n          `step-${step}-end`\n        );\n        \n        transitionTimes.push(stepTime);\n      }\n\n      // Each transition should be under 500ms\n      transitionTimes.forEach((time, index) => {\n        expect(time).toBeLessThan(500);\n      });\n\n      const initTime = performanceTracker.measure(\n        'checkin-initialization',\n        'checkin-start',\n        'checkin-init'\n      );\n\n      expect(initTime).toBeLessThan(200);\n    });\n  });\n\n  describe('Concurrent Performance Under Load', () => {\n    test('Multiple simultaneous operations', async () => {\n      const operations = [\n        // Assessment loading\n        () => {\n          const store = useAssessmentStore.getState();\n          return store.loadAssessments();\n        },\n        // Check-in loading\n        () => {\n          const store = useCheckInStore.getState();\n          return store.loadCheckIns();\n        },\n        // Data store operation\n        () => dataStore.validateData(),\n        // Emergency call simulation\n        () => Promise.resolve('emergency-ready')\n      ];\n\n      performanceTracker.mark('concurrent-start');\n      \n      const results = await Promise.all(operations.map(op => op()));\n      \n      performanceTracker.mark('concurrent-end');\n\n      const concurrentTime = performanceTracker.measure(\n        'concurrent-operations',\n        'concurrent-start',\n        'concurrent-end'\n      );\n\n      // All operations should complete within reasonable time\n      expect(concurrentTime).toBeLessThan(2000);\n      expect(results).toHaveLength(4);\n    });\n  });\n});",
          "size": 13875,
          "lines": 442,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": false,
          "hasAsyncTests": true,
          "hasExpectations": true
        },
        {
          "path": "src/__tests__/performance/AppLaunchPerformance.test.ts",
          "exists": true,
          "content": "/**\n * App Launch Performance Tests\n * TARGET: <3000ms cold start, <1000ms warm start, <500ms hot start\n */\n\nimport { render } from '@testing-library/react-native';\nimport App from '../../../App';\n\n// Mock navigation and dependencies for testing\njest.mock('@react-navigation/native', () => ({\n  NavigationContainer: ({ children }: any) => children,\n  useNavigation: () => ({\n    navigate: jest.fn(),\n    goBack: jest.fn(),\n  }),\n}));\n\njest.mock('../../store', () => ({\n  useUserStore: () => ({\n    user: { id: '1', name: 'Test User' },\n    isLoading: false,\n    loadUser: jest.fn(),\n    isOnboardingComplete: () => true,\n  }),\n  useCheckInStore: () => ({\n    todaysCheckIns: [],\n    loadTodaysCheckIns: jest.fn(),\n    getTodaysProgress: () => ({ completed: 0, total: 3 }),\n    hasCompletedTodaysCheckIn: () => false,\n  }),\n}));\n\ndescribe('App Launch Performance Tests', () => {\n  \n  beforeEach(() => {\n    // Clear any cached modules\n    jest.clearAllMocks();\n  });\n\n  test('should achieve cold start in <3000ms', async () => {\n    const TARGET_COLD_START = 3000;\n    \n    const startTime = performance.now();\n    \n    // Simulate cold start - app not in memory\n    const { findByText } = render(<App />);\n    \n    // Wait for app to be ready (should show home screen greeting)\n    const greeting = await findByText(/Good (morning|afternoon|evening)/i, {}, { timeout: 5000 });\n    \n    const coldStartTime = performance.now() - startTime;\n    \n    expect(greeting).toBeTruthy();\n    expect(coldStartTime).toBeLessThan(TARGET_COLD_START);\n    \n    console.log('Cold Start Performance Report:');\n    console.log(`Cold start time: ${coldStartTime.toFixed(2)}ms`);\n    console.log(`Target: <${TARGET_COLD_START}ms`);\n    console.log(`Performance met: ${coldStartTime < TARGET_COLD_START ? 'YES' : 'NO'}`);\n  });\n\n  test('should load critical UI elements first', async () => {\n    const CRITICAL_ELEMENTS_TIMEOUT = 1000; // Critical UI should appear within 1 second\n    \n    const startTime = performance.now();\n    \n    const { findByText, findByDisplayValue } = render(<App />);\n    \n    // Check that critical elements appear quickly\n    const promises = [\n      findByText(/Good (morning|afternoon|evening)/i, {}, { timeout: CRITICAL_ELEMENTS_TIMEOUT }),\n      findByText(/Today's Progress/i, {}, { timeout: CRITICAL_ELEMENTS_TIMEOUT }),\n    ];\n    \n    const results = await Promise.allSettled(promises);\n    const criticalLoadTime = performance.now() - startTime;\n    \n    // At least the greeting should load within 1 second\n    expect(results[0].status).toBe('fulfilled');\n    expect(criticalLoadTime).toBeLessThan(CRITICAL_ELEMENTS_TIMEOUT);\n    \n    console.log('Critical UI Load Performance Report:');\n    console.log(`Critical elements loaded in: ${criticalLoadTime.toFixed(2)}ms`);\n    console.log(`Elements loaded: ${results.filter(r => r.status === 'fulfilled').length}/${results.length}`);\n  });\n\n  test('should defer non-critical operations', async () => {\n    const NON_CRITICAL_DELAY = 500; // Non-critical operations should be deferred at least 500ms\n    \n    const startTime = performance.now();\n    let backgroundInitStarted = false;\n    \n    // Mock console.log to detect background initialization\n    const originalLog = console.log;\n    console.log = jest.fn((message: string) => {\n      if (message === 'Background initialization started') {\n        backgroundInitStarted = true;\n        const deferralTime = performance.now() - startTime;\n        \n        expect(deferralTime).toBeGreaterThan(NON_CRITICAL_DELAY);\n        \n        console.log('Background Initialization Performance Report:');\n        originalLog(`Background init deferred by: ${deferralTime.toFixed(2)}ms`);\n      }\n      originalLog(message);\n    });\n    \n    render(<App />);\n    \n    // Wait for background initialization\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    expect(backgroundInitStarted).toBe(true);\n    \n    // Restore console.log\n    console.log = originalLog;\n  });\n\n  test('should handle app state transitions efficiently', async () => {\n    const TRANSITION_TIME_LIMIT = 200;\n    \n    const { rerender } = render(<App />);\n    \n    // Simulate app going to background and returning\n    const transitionStart = performance.now();\n    \n    // Force re-render (simulates app state change)\n    rerender(<App />);\n    \n    const transitionTime = performance.now() - transitionStart;\n    \n    expect(transitionTime).toBeLessThan(TRANSITION_TIME_LIMIT);\n    \n    console.log('App State Transition Performance Report:');\n    console.log(`Transition time: ${transitionTime.toFixed(2)}ms`);\n    console.log(`Target: <${TRANSITION_TIME_LIMIT}ms`);\n  });\n\n  test('should maintain memory efficiency during initialization', async () => {\n    const MEMORY_GROWTH_LIMIT = 50 * 1024 * 1024; // 50MB limit\n    \n    // Simulate initial memory state\n    const initialMemory = 30 * 1024 * 1024; // 30MB baseline\n    let currentMemory = initialMemory;\n    \n    // Mock memory tracking\n    const originalGC = global.gc;\n    global.gc = jest.fn(() => {\n      currentMemory *= 0.9; // Simulate garbage collection\n    });\n    \n    render(<App />);\n    \n    // Simulate memory usage during app initialization\n    currentMemory += Math.random() * 20 * 1024 * 1024; // Up to 20MB growth\n    \n    const memoryGrowth = currentMemory - initialMemory;\n    \n    expect(memoryGrowth).toBeLessThan(MEMORY_GROWTH_LIMIT);\n    \n    console.log('Memory Efficiency Performance Report:');\n    console.log(`Initial memory: ${(initialMemory / 1024 / 1024).toFixed(2)}MB`);\n    console.log(`Peak memory: ${(currentMemory / 1024 / 1024).toFixed(2)}MB`);\n    console.log(`Memory growth: ${(memoryGrowth / 1024 / 1024).toFixed(2)}MB`);\n    console.log(`Within limits: ${memoryGrowth < MEMORY_GROWTH_LIMIT ? 'YES' : 'NO'}`);\n    \n    // Restore global.gc\n    global.gc = originalGC;\n  });\n});\n\n// Bundle Performance Tests\ndescribe('Bundle Performance Tests', () => {\n  \n  test('should maintain reasonable bundle size', () => {\n    // This would normally analyze actual bundle size\n    // For testing, we'll simulate bundle analysis\n    \n    const BUNDLE_SIZE_LIMIT = 50 * 1024 * 1024; // 50MB\n    \n    // Simulate bundle components\n    const bundleComponents = {\n      javascript: 8 * 1024 * 1024,    // 8MB JS\n      images: 5 * 1024 * 1024,        // 5MB images\n      fonts: 2 * 1024 * 1024,         // 2MB fonts\n      dependencies: 15 * 1024 * 1024,  // 15MB dependencies\n      other: 3 * 1024 * 1024,         // 3MB other\n    };\n    \n    const totalBundleSize = Object.values(bundleComponents).reduce((sum, size) => sum + size, 0);\n    \n    expect(totalBundleSize).toBeLessThan(BUNDLE_SIZE_LIMIT);\n    \n    console.log('Bundle Size Analysis Report:');\n    Object.entries(bundleComponents).forEach(([component, size]) => {\n      console.log(`${component}: ${(size / 1024 / 1024).toFixed(2)}MB`);\n    });\n    console.log(`Total bundle size: ${(totalBundleSize / 1024 / 1024).toFixed(2)}MB`);\n    console.log(`Under limit: ${totalBundleSize < BUNDLE_SIZE_LIMIT ? 'YES' : 'NO'}`);\n  });\n\n  test('should identify performance bottlenecks', () => {\n    // Simulate performance bottleneck analysis\n    const performanceMetrics = {\n      heavyDependencies: [\n        { name: 'react-native-reanimated', size: 3.2, impact: 'high' },\n        { name: '@react-navigation/native', size: 1.8, impact: 'medium' },\n        { name: 'zustand', size: 0.1, impact: 'low' },\n      ],\n      unusedDependencies: [],\n      duplicateDependencies: [],\n    };\n    \n    // Check for heavy dependencies\n    const heavyDeps = performanceMetrics.heavyDependencies.filter(dep => dep.size > 2.0);\n    expect(heavyDeps.length).toBeLessThanOrEqual(2); // Allow some heavy deps for functionality\n    \n    console.log('Bundle Performance Analysis:');\n    console.log(`Heavy dependencies (>2MB): ${heavyDeps.length}`);\n    heavyDeps.forEach(dep => {\n      console.log(`- ${dep.name}: ${dep.size}MB (${dep.impact} impact)`);\n    });\n  });\n});\n\n// Device-Specific Performance Tests\ndescribe('Device-Specific Performance Tests', () => {\n  \n  const deviceProfiles = [\n    { name: 'iPhone 12', memory: 4096, cpu: 'A14', performance: 'medium' },\n    { name: 'iPhone 14', memory: 6144, cpu: 'A15', performance: 'high' },\n    { name: 'Samsung Galaxy S21', memory: 8192, cpu: 'Snapdragon 888', performance: 'medium' },\n    { name: 'Samsung Galaxy S23', memory: 8192, cpu: 'Snapdragon 8 Gen 2', performance: 'high' },\n  ];\n\n  deviceProfiles.forEach(device => {\n    test(`should perform adequately on ${device.name}`, () => {\n      // Simulate device-specific performance requirements\n      const performanceRequirements = {\n        launchTime: device.performance === 'high' ? 2000 : 3000,\n        breathingAnimation: 60, // FPS\n        crisisResponse: 200, // ms\n        memoryUsage: Math.min(device.memory * 0.1, 150), // 10% of device memory or 150MB, whichever is lower\n      };\n      \n      // All devices should meet minimum requirements\n      expect(performanceRequirements.launchTime).toBeLessThanOrEqual(3000);\n      expect(performanceRequirements.breathingAnimation).toBeGreaterThanOrEqual(60);\n      expect(performanceRequirements.crisisResponse).toBeLessThanOrEqual(200);\n      expect(performanceRequirements.memoryUsage).toBeLessThanOrEqual(150);\n      \n      console.log(`${device.name} Performance Profile:`);\n      console.log(`- Launch time target: ${performanceRequirements.launchTime}ms`);\n      console.log(`- Animation target: ${performanceRequirements.breathingAnimation}fps`);\n      console.log(`- Crisis response: ${performanceRequirements.crisisResponse}ms`);\n      console.log(`- Memory limit: ${performanceRequirements.memoryUsage}MB`);\n    });\n  });\n});",
          "size": 9715,
          "lines": 259,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": true,
          "hasAsyncTests": true,
          "hasExpectations": true
        }
      ],
      "totalFiles": 2,
      "existingFiles": 2,
      "totalLines": 701,
      "hasTests": 2,
      "requirements": [
        "Payment screen navigation <300ms",
        "Stripe Elements loading <1 second",
        "Crisis feature activation <200ms",
        "Subscription status sync <500ms",
        "Error recovery messaging <100ms"
      ],
      "coverage": 100
    },
    "accessibility": {
      "name": "Accessibility Testing",
      "icon": "â™¿",
      "files": [
        {
          "path": "src/components/accessibility/__tests__/PaymentAccessibilityTests.tsx",
          "exists": true,
          "content": "/**\n * Payment Accessibility Testing Suite - WCAG AA Compliance Validation\n *\n * TESTING COVERAGE:\n * - WCAG 2.1 AA compliance verification\n * - Screen reader compatibility across VoiceOver/TalkBack\n * - Crisis safety feature accessibility\n * - High contrast and reduced motion support\n * - Keyboard navigation and focus management\n * - Color contrast ratio validation\n * - Touch target size verification (44px minimum)\n */\n\nimport React from 'react';\nimport { render, fireEvent, waitFor } from '@testing-library/react-native';\nimport { AccessibilityInfo, Linking } from 'react-native';\nimport { PaymentAccessibilityProvider } from '../PaymentAccessibilityProvider';\nimport { AccessiblePaymentForm } from '../AccessiblePaymentForm';\nimport { PaymentAccessibilityOverlay } from '../PaymentAccessibilityOverlay';\nimport TherapeuticPaymentMessaging from '../../payment/TherapeuticPaymentMessaging';\n\n// Mock external dependencies\njest.mock('react-native', () => ({\n  ...jest.requireActual('react-native'),\n  AccessibilityInfo: {\n    isScreenReaderEnabled: jest.fn(),\n    isReduceMotionEnabled: jest.fn(),\n    announceForAccessibility: jest.fn(),\n    setAccessibilityFocus: jest.fn(),\n    addEventListener: jest.fn(() => ({ remove: jest.fn() })),\n  },\n  Appearance: {\n    getColorScheme: jest.fn(() => 'light'),\n    addChangeListener: jest.fn(() => ({ remove: jest.fn() })),\n  },\n  Linking: {\n    openURL: jest.fn(),\n  },\n}));\n\njest.mock('../../store', () => ({\n  useCrisisPaymentSafety: () => ({\n    crisisMode: false,\n    crisisOverride: null,\n    enableCrisisMode: jest.fn(),\n    performanceMetrics: {},\n  }),\n}));\n\nconst mockAccessibilityInfo = AccessibilityInfo as jest.Mocked<typeof AccessibilityInfo>;\nconst mockLinking = Linking as jest.Mocked<typeof Linking>;\n\ndescribe('Payment Accessibility Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(false);\n    mockAccessibilityInfo.isReduceMotionEnabled.mockResolvedValue(false);\n  });\n\n  describe('WCAG AA Compliance', () => {\n    test('all interactive elements meet 44px minimum touch target', async () => {\n      const { getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const buttons = getAllByRole('button');\n\n      // Check each button meets minimum touch target size\n      buttons.forEach(button => {\n        const style = button.props.style;\n        const minHeight = Array.isArray(style)\n          ? style.find(s => s && s.minHeight)?.minHeight\n          : style?.minHeight;\n\n        expect(minHeight).toBeGreaterThanOrEqual(44);\n      });\n    });\n\n    test('crisis buttons have enhanced 48px touch targets', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"financial_stress\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Call 988/i);\n      const style = crisisButton.props.style;\n      const minHeight = Array.isArray(style)\n        ? style.find(s => s && s.minHeight)?.minHeight\n        : style?.minHeight;\n\n      expect(minHeight).toBeGreaterThanOrEqual(48);\n    });\n\n    test('color contrast meets 4.5:1 ratio for normal text', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"payment_success\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      expect(alert).toBeTruthy();\n\n      // Color contrast would be verified through visual testing tools\n      // Here we verify the contrast checking function exists and is used\n      expect(alert.props.accessibilityLabel).toBeTruthy();\n    });\n\n    test('crisis elements meet 7:1 contrast ratio for enhanced visibility', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"crisis_override\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      expect(alert.props.accessibilityLiveRegion).toBe('assertive');\n    });\n  });\n\n  describe('Screen Reader Compatibility', () => {\n    beforeEach(() => {\n      mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(true);\n    });\n\n    test('payment form announces progress to screen readers', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n            showProgressIndicator={true}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalledWith(\n          expect.stringContaining('Payment form progress')\n        );\n      });\n    });\n\n    test('form field errors announced with therapeutic language', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const submitButton = getByLabelText(/Complete Payment/i);\n      fireEvent.press(submitButton);\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalledWith(\n          expect.stringContaining('required'),\n          'polite'\n        );\n      });\n    });\n\n    test('crisis activation announced with assertive priority', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"financial_stress\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Activate crisis/i);\n      fireEvent.press(crisisButton);\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalledWith(\n          expect.stringContaining('Crisis support activated'),\n          'assertive'\n        );\n      });\n    });\n\n    test('therapeutic messaging uses simplified language for screen readers', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging\n            scenario=\"payment_failure\"\n            errorCode=\"insufficient_funds\"\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      const accessibilityLabel = alert.props.accessibilityLabel;\n\n      // Verify simplified language is used\n      expect(accessibilityLabel).not.toContain('insufficient funds');\n      expect(accessibilityLabel).toContain('not enough money');\n    });\n  });\n\n  describe('Crisis Safety Accessibility', () => {\n    test('988 hotline accessible within 3 seconds via multiple methods', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Call 988/i);\n\n      // Test button exists and is immediately accessible\n      expect(crisisButton).toBeTruthy();\n\n      const startTime = Date.now();\n      fireEvent.press(crisisButton);\n      const responseTime = Date.now() - startTime;\n\n      // Should be essentially instant in tests\n      expect(responseTime).toBeLessThan(100);\n      expect(mockLinking.openURL).toHaveBeenCalledWith('tel:988');\n    });\n\n    test('crisis mode prioritizes accessibility features', async () => {\n      // Mock crisis mode enabled\n      const mockCrisisStore = {\n        crisisMode: true,\n        crisisOverride: { expires: Date.now() + 86400000, crisisSessionId: 'test123' },\n        enableCrisisMode: jest.fn(),\n        performanceMetrics: {},\n      };\n\n      jest.doMock('../../store', () => ({\n        useCrisisPaymentSafety: () => mockCrisisStore,\n      }));\n\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"crisis_override\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      expect(alert.props.accessibilityLiveRegion).toBe('assertive');\n    });\n\n    test('crisis elements have enhanced hitSlop for stress situations', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"financial_stress\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Call 988/i);\n      expect(crisisButton.props.hitSlop).toEqual({\n        top: 8,\n        bottom: 8,\n        left: 8,\n        right: 8,\n      });\n    });\n  });\n\n  describe('High Contrast and Visual Accessibility', () => {\n    test('high contrast mode increases border widths and shadows', async () => {\n      // Mock high contrast enabled\n      mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(false);\n\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <PaymentAccessibilityOverlay\n            visible={true}\n            onClose={jest.fn()}\n            onSettingsChange={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const toggles = getAllByRole('switch');\n      const highContrastToggle = toggles.find(toggle =>\n        toggle.props.accessibilityLabel?.includes('High contrast')\n      );\n\n      expect(highContrastToggle).toBeTruthy();\n    });\n\n    test('reduced motion preferences disable animations', async () => {\n      mockAccessibilityInfo.isReduceMotionEnabled.mockResolvedValue(true);\n\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <PaymentAccessibilityOverlay\n            visible={true}\n            onClose={jest.fn()}\n            onSettingsChange={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      // Animation durations should be reduced when motion is disabled\n      // This would be tested through animation mock verification\n      expect(getByRole('dialog')).toBeTruthy();\n    });\n\n    test('color-blind support uses patterns and shapes', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <PaymentAccessibilityOverlay\n            visible={true}\n            onClose={jest.fn()}\n            onSettingsChange={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const colorBlindToggle = getByLabelText(/Color blind support/i);\n      fireEvent.press(colorBlindToggle);\n\n      // Color blind support toggle should be available\n      expect(colorBlindToggle).toBeTruthy();\n    });\n  });\n\n  describe('Keyboard Navigation', () => {\n    test('tab order prioritizes crisis elements', async () => {\n      const { getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const buttons = getAllByRole('button');\n\n      // Crisis button should be first in tab order (index 0)\n      const crisisButton = buttons.find(button =>\n        button.props.accessibilityLabel?.includes('988')\n      );\n\n      expect(crisisButton).toBeTruthy();\n    });\n\n    test('form fields have logical tab progression', async () => {\n      const { getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const textInputs = getAllByRole('text');\n\n      // Each input should have returnKeyType for navigation\n      textInputs.forEach((input, index) => {\n        const expectedReturnKey = index < textInputs.length - 1 ? 'next' : 'done';\n        expect(input.props.returnKeyType).toBe(expectedReturnKey);\n      });\n    });\n  });\n\n  describe('Cognitive Accessibility', () => {\n    test('simplified language option reduces complex terminology', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging\n            scenario=\"payment_failure\"\n            errorCode=\"authentication_required\"\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      const message = alert.props.accessibilityLabel;\n\n      // Should use \"verification\" instead of \"authentication\"\n      expect(message).toContain('verification');\n      expect(message).not.toContain('authentication');\n    });\n\n    test('therapeutic messaging provides stress-reducing context', async () => {\n      const { getByRole } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"retry_guidance\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      const alert = getByRole('alert');\n      expect(alert.props.accessibilityLabel).toContain('mindful');\n      expect(alert.props.accessibilityLabel).toContain('no pressure');\n    });\n\n    test('form provides step-by-step guidance', async () => {\n      const { getByText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n            showProgressIndicator={true}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const progressText = getByText(/Payment Form Progress/i);\n      expect(progressText).toBeTruthy();\n    });\n  });\n\n  describe('Performance Requirements', () => {\n    test('screen reader announcements complete within 1 second', async () => {\n      mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(true);\n\n      const startTime = Date.now();\n\n      render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging scenario=\"payment_success\" />\n        </PaymentAccessibilityProvider>\n      );\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalled();\n      }, { timeout: 1000 });\n\n      const responseTime = Date.now() - startTime;\n      expect(responseTime).toBeLessThan(1000);\n    });\n\n    test('crisis button response time under 200ms', async () => {\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const crisisButton = getByLabelText(/Call 988/i);\n\n      const startTime = Date.now();\n      fireEvent.press(crisisButton);\n      const responseTime = Date.now() - startTime;\n\n      expect(responseTime).toBeLessThan(200);\n      expect(mockLinking.openURL).toHaveBeenCalledWith('tel:988');\n    });\n\n    test('keyboard navigation between elements under 100ms', async () => {\n      const { getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      const inputs = getAllByRole('text');\n\n      if (inputs.length > 1) {\n        const startTime = Date.now();\n        fireEvent(inputs[0], 'submitEditing');\n        const responseTime = Date.now() - startTime;\n\n        // Navigation should be nearly instantaneous\n        expect(responseTime).toBeLessThan(100);\n      }\n    });\n  });\n\n  describe('Integration Tests', () => {\n    test('payment form with all accessibility features enabled', async () => {\n      mockAccessibilityInfo.isScreenReaderEnabled.mockResolvedValue(true);\n      mockAccessibilityInfo.isReduceMotionEnabled.mockResolvedValue(true);\n\n      const { getByLabelText, getAllByRole } = render(\n        <PaymentAccessibilityProvider>\n          <AccessiblePaymentForm\n            onSubmit={jest.fn()}\n            onCancel={jest.fn()}\n            showProgressIndicator={true}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      // Crisis support should be accessible\n      const crisisButton = getByLabelText(/Call 988/i);\n      expect(crisisButton).toBeTruthy();\n\n      // Form fields should have accessibility labels\n      const inputs = getAllByRole('text');\n      inputs.forEach(input => {\n        expect(input.props.accessibilityLabel).toBeTruthy();\n        expect(input.props.accessibilityHint).toBeTruthy();\n      });\n\n      // Progress indicator should be accessible\n      expect(getByText(/Payment Form Progress/i)).toBeTruthy();\n    });\n\n    test('therapeutic messaging with crisis escalation path', async () => {\n      const onCrisisSupport = jest.fn();\n\n      const { getByLabelText } = render(\n        <PaymentAccessibilityProvider>\n          <TherapeuticPaymentMessaging\n            scenario=\"financial_stress\"\n            onCrisisSupport={onCrisisSupport}\n          />\n        </PaymentAccessibilityProvider>\n      );\n\n      // Test crisis escalation path\n      const crisisButton = getByLabelText(/Activate crisis/i);\n      fireEvent.press(crisisButton);\n\n      expect(onCrisisSupport).toHaveBeenCalled();\n\n      await waitFor(() => {\n        expect(mockAccessibilityInfo.announceForAccessibility).toHaveBeenCalledWith(\n          expect.stringContaining('Crisis support activated'),\n          'assertive'\n        );\n      });\n    });\n  });\n});\n\n// Helper function to get all elements by role (compatibility fix)\nfunction getAllByRole(container: any, role: string) {\n  const elements = container.queryAllByRole ? container.queryAllByRole(role) : [];\n  return elements.filter((el: any) => el && el.props);\n}\n\nexport default PaymentAccessibilityTests;",
          "size": 17922,
          "lines": 548,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": true,
          "hasAsyncTests": true,
          "hasExpectations": true
        },
        {
          "path": "__tests__/accessibility/wcag-compliance.test.tsx",
          "exists": true,
          "content": "/**\n * Accessibility Tests - WCAG AA Compliance\n * \n * Critical for mental health app - users in crisis need full accessibility\n * Tests screen reader compatibility, focus management, and inclusive design\n */\n\nimport React from 'react';\nimport { render, fireEvent } from '@testing-library/react-native';\nimport { AccessibilityInfo } from 'react-native';\n\n// Mock accessibility components\nconst MockCrisisButton = ({ onPress, testID }: { onPress: () => void; testID: string }) => (\n  <TouchableOpacity\n    testID={testID}\n    onPress={onPress}\n    accessible={true}\n    accessibilityRole=\"button\"\n    accessibilityLabel=\"Emergency crisis support - Call 988 for immediate help\"\n    accessibilityHint=\"Double tap to call the crisis hotline immediately\"\n    style={{ minHeight: 44, minWidth: 44, padding: 12 }}\n  >\n    <Text style={{ fontSize: 18, fontWeight: 'bold' }}>Call 988</Text>\n  </TouchableOpacity>\n);\n\nconst MockAssessmentQuestion = ({ \n  question, \n  options, \n  onAnswer,\n  currentQuestion,\n  totalQuestions \n}: any) => (\n  <View\n    accessible={true}\n    accessibilityRole=\"group\"\n    accessibilityLabel={`Assessment question ${currentQuestion} of ${totalQuestions}`}\n  >\n    <Text\n      accessibilityRole=\"header\"\n      accessibilityLevel={2}\n      style={{ fontSize: 18, marginBottom: 16 }}\n    >\n      {question}\n    </Text>\n    {options.map((option: any, index: number) => (\n      <TouchableOpacity\n        key={index}\n        testID={`answer-option-${index}`}\n        onPress={() => onAnswer(option.value)}\n        accessible={true}\n        accessibilityRole=\"button\"\n        accessibilityLabel={`${option.text}. Option ${index + 1} of ${options.length}`}\n        accessibilityState={{ selected: false }}\n        style={{ \n          minHeight: 44, \n          padding: 12, \n          marginVertical: 4,\n          backgroundColor: '#f0f0f0'\n        }}\n      >\n        <Text style={{ fontSize: 16 }}>{option.text}</Text>\n      </TouchableOpacity>\n    ))}\n  </View>\n);\n\nconst MockBreathingCircle = ({ isPlaying, onToggle }: { isPlaying: boolean; onToggle: () => void }) => (\n  <View\n    testID=\"breathing-circle-container\"\n    accessible={true}\n    accessibilityRole=\"button\"\n    accessibilityLabel={isPlaying ? \"Breathing exercise in progress. Tap to pause.\" : \"Breathing exercise paused. Tap to start.\"}\n    accessibilityState={{ selected: isPlaying }}\n    style={{ width: 200, height: 200, borderRadius: 100 }}\n  >\n    <TouchableOpacity onPress={onToggle} style={{ flex: 1 }} testID=\"breathing-toggle\">\n      <View\n        style={{\n          flex: 1,\n          backgroundColor: isPlaying ? '#4CAF50' : '#FFC107',\n          borderRadius: 100,\n          transform: [{ scale: isPlaying ? 1.2 : 1.0 }]\n        }}\n      />\n    </TouchableOpacity>\n  </View>\n);\n\n// Import required components\nimport { TouchableOpacity, View, Text } from 'react-native';\nimport { useCrisisIntervention } from '../../src/hooks/useCrisisIntervention';\n\ndescribe('Accessibility: WCAG AA Compliance', () => {\n  beforeEach(() => {\n    // Mock AccessibilityInfo\n    (AccessibilityInfo as any).isScreenReaderEnabled = jest.fn().mockResolvedValue(true);\n    (AccessibilityInfo as any).announceForAccessibility = jest.fn();\n  });\n\n  describe('Critical Crisis Elements - Level AAA', () => {\n    test('Crisis button meets accessibility requirements', () => {\n      const mockOnPress = jest.fn();\n      const { getByTestId } = render(\n        <MockCrisisButton onPress={mockOnPress} testID=\"crisis-button\" />\n      );\n\n      const button = getByTestId('crisis-button');\n\n      // Test touch target size (minimum 48x48 points for crisis)\n      expect(button.props.style).toMatchObject({\n        minHeight: 48, // Updated to higher standard for crisis\n        minWidth: 48\n      });\n\n      // Test accessibility properties\n      expect(button.props.accessible).toBe(true);\n      expect(button.props.accessibilityRole).toBe('button');\n      expect(button.props.accessibilityLabel).toContain('Emergency crisis support');\n      expect(button.props.accessibilityLabel).toContain('Call 988');\n      expect(button.props.accessibilityHint).toContain('Calls crisis hotline immediately');\n\n      // Test interaction\n      fireEvent.press(button);\n      expect(mockOnPress).toHaveBeenCalled();\n    });\n\n    test('Crisis intervention triggers immediate announcement', async () => {\n      const mockAnnounce = jest.fn();\n      (AccessibilityInfo as any).announceForAccessibility = mockAnnounce;\n\n      const CrisisComponent = () => {\n        const { triggerCrisisIntervention } = useCrisisIntervention();\n        \n        React.useEffect(() => {\n          triggerCrisisIntervention({\n            immediate: true,\n            source: 'assessment',\n            context: 'PHQ-9 score: 22'\n          });\n        }, []);\n\n        return <View testID=\"crisis-component\" />;\n      };\n\n      render(<CrisisComponent />);\n      \n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      expect(mockAnnounce).toHaveBeenCalledWith(\n        'URGENT: Crisis support needed. Emergency resources are now available.',\n        { urgency: 'high' }\n      );\n    });\n\n    test('Crisis screen content is screen reader accessible', () => {\n      const CrisisScreen = () => (\n        <View\n          testID=\"crisis-screen\"\n          accessibilityRole=\"main\"\n          accessibilityLabel=\"Crisis support screen\"\n        >\n          <Text\n            accessibilityRole=\"header\"\n            accessibilityLevel={1}\n            style={{ fontSize: 24, fontWeight: 'bold' }}\n          >\n            Crisis Support\n          </Text>\n          <Text\n            accessible={true}\n            accessibilityLabel=\"You are not alone. Help is available right now.\"\n            style={{ fontSize: 16, marginVertical: 8 }}\n          >\n            You are not alone. Help is available right now.\n          </Text>\n          <MockCrisisButton\n            onPress={() => {}}\n            testID=\"primary-crisis-button\"\n          />\n        </View>\n      );\n\n      const { getByTestId } = render(<CrisisScreen />);\n      \n      const screen = getByTestId('crisis-screen');\n      expect(screen.props.accessibilityRole).toBe('main');\n      expect(screen.props.accessibilityLabel).toBe('Crisis support screen');\n\n      const button = getByTestId('primary-crisis-button');\n      expect(button.props.accessible).toBe(true);\n    });\n\n    test('Emergency contact calling accessibility', async () => {\n      const mockAnnounce = jest.fn();\n      (AccessibilityInfo as any).announceForAccessibility = mockAnnounce;\n\n      const EmergencyCallHandler = () => {\n        const handleCall = () => {\n          // Announce call initiation to screen reader\n          AccessibilityInfo.announceForAccessibility(\n            'Calling 988 crisis hotline now. Please wait.'\n          );\n        };\n\n        return (\n          <MockCrisisButton \n            onPress={handleCall}\n            testID=\"emergency-call\"\n          />\n        );\n      };\n\n      const { getByTestId } = render(<EmergencyCallHandler />);\n      \n      fireEvent.press(getByTestId('emergency-call'));\n      \n      expect(mockAnnounce).toHaveBeenCalledWith(\n        'Calling 988 crisis hotline now. Please wait.'\n      );\n    });\n  });\n\n  describe('Assessment Accessibility', () => {\n    test('PHQ-9 questions are properly structured for screen readers', () => {\n      const questionData = {\n        question: 'Little interest or pleasure in doing things',\n        options: [\n          { value: 0, text: 'Not at all' },\n          { value: 1, text: 'Several days' },\n          { value: 2, text: 'More than half the days' },\n          { value: 3, text: 'Nearly every day' }\n        ],\n        currentQuestion: 1,\n        totalQuestions: 9\n      };\n\n      const { getByTestId } = render(\n        <MockAssessmentQuestion\n          {...questionData}\n          onAnswer={() => {}}\n        />\n      );\n\n      // Test each answer option\n      questionData.options.forEach((option, index) => {\n        const optionElement = getByTestId(`answer-option-${index}`);\n        \n        expect(optionElement.props.accessible).toBe(true);\n        expect(optionElement.props.accessibilityRole).toBe('button');\n        expect(optionElement.props.accessibilityLabel).toContain(option.text);\n        expect(optionElement.props.accessibilityLabel).toContain(`Option ${index + 1} of 4`);\n        \n        // Test minimum touch target\n        expect(optionElement.props.style.minHeight).toBe(44);\n      });\n    });\n\n    test('Assessment progress announcement', () => {\n      const mockAnnounce = jest.fn();\n      (AccessibilityInfo as any).announceForAccessibility = mockAnnounce;\n\n      const AssessmentWithProgress = () => {\n        const [currentQuestion, setCurrentQuestion] = React.useState(0);\n        \n        const handleAnswer = (value: number) => {\n          const nextQuestion = currentQuestion + 1;\n          setCurrentQuestion(nextQuestion);\n          \n          if (nextQuestion <= 9) {\n            AccessibilityInfo.announceForAccessibility(\n              `Question ${nextQuestion} of 9 completed. Moving to next question.`\n            );\n          } else {\n            AccessibilityInfo.announceForAccessibility(\n              'Assessment completed. Processing your responses.'\n            );\n          }\n        };\n\n        if (currentQuestion >= 9) {\n          return (\n            <Text \n              testID=\"assessment-complete\"\n              accessibilityLiveRegion=\"polite\"\n            >\n              Assessment completed\n            </Text>\n          );\n        }\n\n        return (\n          <MockAssessmentQuestion\n            question=\"Test question\"\n            options={[{ value: 1, text: 'Test answer' }]}\n            currentQuestion={currentQuestion + 1}\n            totalQuestions={9}\n            onAnswer={handleAnswer}\n          />\n        );\n      };\n\n      const { getByTestId } = render(<AssessmentWithProgress />);\n      \n      fireEvent.press(getByTestId('answer-option-0'));\n      \n      expect(mockAnnounce).toHaveBeenCalledWith(\n        'Question 1 of 9 completed. Moving to next question.'\n      );\n    });\n\n    test('Crisis detection announcement', () => {\n      const mockAnnounce = jest.fn();\n      (AccessibilityInfo as any).announceForAccessibility = mockAnnounce;\n\n      const CrisisDetectionComponent = () => {\n        const handleCrisisDetected = () => {\n          // Immediate announcement for crisis\n          AccessibilityInfo.announceForAccessibility(\n            'Important: Your responses indicate you may need immediate support. Crisis resources are being displayed.',\n            { urgency: 'high' } as any\n          );\n        };\n\n        React.useEffect(() => {\n          handleCrisisDetected();\n        }, []);\n\n        return (\n          <View testID=\"crisis-detected\">\n            <Text>Crisis resources available</Text>\n          </View>\n        );\n      };\n\n      render(<CrisisDetectionComponent />);\n      \n      expect(mockAnnounce).toHaveBeenCalledWith(\n        'Important: Your responses indicate you may need immediate support. Crisis resources are being displayed.',\n        { urgency: 'high' }\n      );\n    });\n  });\n\n  describe('Breathing Exercise Accessibility', () => {\n    test('Breathing circle provides audio guidance', () => {\n      const mockAnnounce = jest.fn();\n      (AccessibilityInfo as any).announceForAccessibility = mockAnnounce;\n\n      const BreathingExercise = () => {\n        const [isPlaying, setIsPlaying] = React.useState(false);\n        const [phase, setPhase] = React.useState<'inhale' | 'hold' | 'exhale' | 'pause'>('inhale');\n\n        const handleToggle = () => {\n          const newPlaying = !isPlaying;\n          setIsPlaying(newPlaying);\n          \n          if (newPlaying) {\n            AccessibilityInfo.announceForAccessibility(\n              'Breathing exercise started. Follow the audio cues: Breathe in for 4 seconds.'\n            );\n          } else {\n            AccessibilityInfo.announceForAccessibility(\n              'Breathing exercise paused. Tap to resume.'\n            );\n          }\n        };\n\n        // Simulate breathing phase announcements\n        React.useEffect(() => {\n          if (isPlaying) {\n            const phaseMessages = {\n              inhale: 'Breathe in slowly for 4 seconds',\n              hold: 'Hold your breath for 4 seconds',\n              exhale: 'Breathe out slowly for 6 seconds',\n              pause: 'Brief pause before next cycle'\n            };\n            \n            AccessibilityInfo.announceForAccessibility(phaseMessages[phase]);\n          }\n        }, [phase, isPlaying]);\n\n        return (\n          <MockBreathingCircle\n            isPlaying={isPlaying}\n            onToggle={handleToggle}\n          />\n        );\n      };\n\n      const { getByTestId } = render(<BreathingExercise />);\n      \n      fireEvent.press(getByTestId('breathing-toggle'));\n      \n      expect(mockAnnounce).toHaveBeenCalledWith(\n        'Breathing exercise started. Follow the audio cues: Breathe in for 4 seconds.'\n      );\n    });\n\n    test('Breathing circle touch target and labels', () => {\n      const { getByTestId } = render(\n        <MockBreathingCircle\n          isPlaying={false}\n          onToggle={() => {}}\n        />\n      );\n\n      const container = getByTestId('breathing-circle-container');\n      \n      expect(container.props.accessible).toBe(true);\n      expect(container.props.accessibilityRole).toBe('button');\n      expect(container.props.accessibilityLabel).toContain('Breathing exercise');\n      expect(container.props.accessibilityLabel).toContain('Tap to start');\n      \n      // Verify sufficient touch target size\n      expect(container.props.style).toMatchObject({\n        width: 200,\n        height: 200\n      });\n    });\n  });\n\n  describe('Navigation & Focus Management', () => {\n    test('Proper focus order in crisis flow', () => {\n      const CrisisFlow = () => (\n        <View testID=\"crisis-flow\">\n          <Text\n            accessibilityRole=\"header\"\n            accessibilityLevel={1}\n            testID=\"crisis-header\"\n          >\n            Crisis Support\n          </Text>\n          <Text testID=\"crisis-description\">\n            You are not alone. Help is available.\n          </Text>\n          <View testID=\"crisis-actions\">\n            <MockCrisisButton \n              onPress={() => {}}\n              testID=\"call-988-button\"\n            />\n            <TouchableOpacity\n              testID=\"call-911-button\"\n              accessible={true}\n              accessibilityRole=\"button\"\n              accessibilityLabel=\"Call 911 for emergency services\"\n              style={{ minHeight: 44, marginTop: 8 }}\n            >\n              <Text>Call 911</Text>\n            </TouchableOpacity>\n          </View>\n        </View>\n      );\n\n      const { getByTestId } = render(<CrisisFlow />);\n      \n      // Verify all interactive elements are accessible\n      expect(getByTestId('call-988-button').props.accessible).toBe(true);\n      expect(getByTestId('call-911-button').props.accessible).toBe(true);\n      \n      // Header should be properly marked\n      expect(getByTestId('crisis-header').props.accessibilityRole).toBe('header');\n    });\n\n    test('Assessment navigation feedback', () => {\n      const mockAnnounce = jest.fn();\n      (AccessibilityInfo as any).announceForAccessibility = mockAnnounce;\n\n      const AssessmentNavigation = () => {\n        const [question, setQuestion] = React.useState(0);\n        \n        const goBack = () => {\n          if (question > 0) {\n            setQuestion(question - 1);\n            AccessibilityInfo.announceForAccessibility(\n              `Moved back to question ${question}. You can change your previous answer.`\n            );\n          }\n        };\n\n        return (\n          <View>\n            <TouchableOpacity\n              testID=\"back-button\"\n              onPress={goBack}\n              accessible={true}\n              accessibilityRole=\"button\"\n              accessibilityLabel=\"Go back to previous question\"\n              disabled={question === 0}\n              style={{ minHeight: 44 }}\n            >\n              <Text>Back</Text>\n            </TouchableOpacity>\n            <Text testID=\"question-counter\">\n              Question {question + 1} of 9\n            </Text>\n          </View>\n        );\n      };\n\n      const { getByTestId } = render(<AssessmentNavigation />);\n      \n      // Initially disabled (first question)\n      const backButton = getByTestId('back-button');\n      expect(backButton.props.disabled).toBe(true);\n    });\n  });\n\n  describe('Color Contrast & Visual Accessibility', () => {\n    test('Crisis button has sufficient contrast', () => {\n      // This would typically be tested with actual color values\n      // For demonstration, we test that high-contrast styling is applied\n      \n      const HighContrastCrisisButton = () => (\n        <TouchableOpacity\n          testID=\"high-contrast-button\"\n          style={{\n            backgroundColor: '#CC0000', // High contrast red\n            color: '#FFFFFF', // White text\n            padding: 16,\n            minHeight: 44\n          }}\n          accessible={true}\n          accessibilityRole=\"button\"\n          accessibilityLabel=\"Emergency help - Call 988\"\n        >\n          <Text style={{ color: '#FFFFFF', fontSize: 18, fontWeight: 'bold' }}>\n            Call 988\n          </Text>\n        </TouchableOpacity>\n      );\n\n      const { getByTestId } = render(<HighContrastCrisisButton />);\n      \n      const button = getByTestId('high-contrast-button');\n      expect(button.props.style).toMatchObject({\n        backgroundColor: '#CC0000',\n        color: '#FFFFFF'\n      });\n    });\n\n    test('Text scaling support', () => {\n      // Test that text scales properly with system font size settings\n      const ScalableText = () => (\n        <Text\n          testID=\"scalable-text\"\n          style={{\n            fontSize: 16,\n            lineHeight: 24\n          }}\n          allowFontScaling={true}\n        >\n          Important mental health information\n        </Text>\n      );\n\n      const { getByTestId } = render(<ScalableText />);\n      \n      const text = getByTestId('scalable-text');\n      expect(text.props.allowFontScaling).toBe(true);\n    });\n  });\n\n  describe('Motion & Animation Accessibility', () => {\n    test('Breathing animation respects reduced motion preferences', () => {\n      // Mock reduced motion preference\n      const mockPrefersReducedMotion = true;\n\n      const AccessibleBreathingCircle = () => {\n        const [scale, setScale] = React.useState(1.0);\n        \n        React.useEffect(() => {\n          if (!mockPrefersReducedMotion) {\n            // Normal breathing animation\n            const interval = setInterval(() => {\n              setScale(prev => prev === 1.0 ? 1.2 : 1.0);\n            }, 2000);\n            return () => clearInterval(interval);\n          }\n        }, []);\n\n        return (\n          <View\n            testID=\"accessible-breathing-circle\"\n            style={{\n              width: 100,\n              height: 100,\n              transform: mockPrefersReducedMotion ? [] : [{ scale }],\n              backgroundColor: '#4CAF50'\n            }}\n            accessible={true}\n            accessibilityLabel={\n              mockPrefersReducedMotion\n                ? 'Breathing guide - audio cues only'\n                : 'Breathing guide with visual animation'\n            }\n          />\n        );\n      };\n\n      const { getByTestId } = render(<AccessibleBreathingCircle />);\n      \n      const circle = getByTestId('accessible-breathing-circle');\n      expect(circle.props.accessibilityLabel).toContain('audio cues only');\n      expect(circle.props.style.transform).toEqual([]);\n    });\n  });\n});",
          "size": 19730,
          "lines": 608,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": false,
          "hasAsyncTests": true,
          "hasExpectations": true
        }
      ],
      "totalFiles": 2,
      "existingFiles": 2,
      "totalLines": 1156,
      "hasTests": 2,
      "requirements": [
        "WCAG AA compliance (4.5:1 contrast ratio)",
        "VoiceOver/TalkBack navigation support",
        "44px minimum touch targets (48px crisis)",
        "High contrast and reduced motion support",
        "Screen reader status announcements"
      ],
      "coverage": 100
    },
    "security": {
      "name": "Security Testing",
      "icon": "ðŸ”",
      "files": [
        {
          "path": "src/services/security/__tests__/PaymentSecurityService.test.ts",
          "exists": true,
          "content": "/**\n * Payment Security Service Test Suite\n *\n * Comprehensive testing for PCI DSS compliance and crisis safety\n * Focus Areas:\n * - PCI DSS Level 2 compliance validation\n * - Crisis bypass functionality (<200ms response)\n * - Payment data isolation from PHI\n * - Fraud detection and rate limiting\n * - Audit logging compliance\n */\n\nimport { PaymentSecurityService } from '../PaymentSecurityService';\nimport { EncryptionService } from '../EncryptionService';\n\n// Mock dependencies\njest.mock('expo-crypto', () => ({\n  getRandomBytesAsync: jest.fn(() => Promise.resolve(new Uint8Array(32).fill(1))),\n  digestStringAsync: jest.fn(() => Promise.resolve('mock_hash'))\n}));\n\njest.mock('expo-secure-store', () => ({\n  setItemAsync: jest.fn(() => Promise.resolve()),\n  getItemAsync: jest.fn(() => Promise.resolve(null)),\n  deleteItemAsync: jest.fn(() => Promise.resolve())\n}));\n\ndescribe('PaymentSecurityService', () => {\n  let paymentSecurity: PaymentSecurityService;\n  let encryptionService: EncryptionService;\n\n  beforeEach(async () => {\n    paymentSecurity = PaymentSecurityService.getInstance();\n    encryptionService = EncryptionService.getInstance();\n\n    // Initialize services\n    await encryptionService.initialize();\n    await paymentSecurity.initialize();\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('PCI DSS Compliance', () => {\n    test('should use separate encryption context for payment data', async () => {\n      const testData = { cardToken: 'tok_test123' };\n      const userId = 'test_user';\n      const deviceId = 'test_device';\n      const sessionId = 'test_session';\n\n      const result = await paymentSecurity.createPaymentToken(\n        testData,\n        userId,\n        deviceId,\n        sessionId\n      );\n\n      expect(result.tokenInfo.tokenId).toBeDefined();\n      expect(result.securityResult.success).toBe(true);\n      expect(result.tokenInfo.metadata.deviceFingerprint).toBeDefined();\n    });\n\n    test('should never store card data locally', async () => {\n      const cardData = {\n        number: '4242424242424242',\n        expiryMonth: 12,\n        expiryYear: 2025,\n        cvc: '123'\n      };\n\n      const result = await paymentSecurity.createPaymentToken(\n        cardData,\n        'test_user',\n        'test_device',\n        'test_session'\n      );\n\n      // Verify no sensitive card data in token\n      expect(result.tokenInfo.tokenId).not.toContain('4242424242424242');\n      expect(JSON.stringify(result.tokenInfo)).not.toContain('123');\n      expect(JSON.stringify(result.tokenInfo)).not.toContain(cardData.number);\n    });\n\n    test('should implement proper key rotation for payment keys', async () => {\n      const status = await paymentSecurity.getPaymentSecurityStatus();\n\n      expect(status.pciCompliant).toBe(true);\n      expect(status.crisisBypassEnabled).toBe(true);\n      expect(status.fraudDetectionActive).toBe(true);\n    });\n\n    test('should enforce rate limiting with PCI DSS requirements', async () => {\n      const userId = 'test_user';\n      const deviceId = 'test_device';\n\n      // Make multiple payment attempts to trigger rate limiting\n      const promises = [];\n      for (let i = 0; i < 15; i++) {\n        promises.push(\n          paymentSecurity.createPaymentToken(\n            { test: 'data' },\n            userId,\n            deviceId,\n            `session_${i}`\n          ).catch(err => err)\n        );\n      }\n\n      const results = await Promise.all(promises);\n\n      // Should have some rate limit failures\n      const failures = results.filter(r => r instanceof Error);\n      expect(failures.length).toBeGreaterThan(0);\n\n      // Check that error mentions rate limiting\n      const rateLimitError = failures.find(f =>\n        f.message.includes('Rate limit exceeded')\n      );\n      expect(rateLimitError).toBeDefined();\n    });\n\n    test('should maintain comprehensive audit logs', async () => {\n      const userId = 'audit_test_user';\n      const deviceId = 'audit_test_device';\n\n      await paymentSecurity.createPaymentToken(\n        { test: 'audit_data' },\n        userId,\n        deviceId,\n        'audit_session'\n      );\n\n      // Audit events should be recorded automatically\n      // In real implementation, would verify audit log entries\n      expect(true).toBe(true); // Placeholder for audit verification\n    });\n  });\n\n  describe('Crisis Safety Protocols', () => {\n    test('should bypass payment security during crisis mode', async () => {\n      const startTime = Date.now();\n\n      const result = await paymentSecurity.createPaymentToken(\n        { emergency: 'payment' },\n        'crisis_user',\n        'crisis_device',\n        'crisis_session',\n        true // Crisis mode\n      );\n\n      const responseTime = Date.now() - startTime;\n\n      expect(result.securityResult.crisisOverride).toBe(true);\n      expect(result.securityResult.action).toBe('bypass');\n      expect(result.securityResult.riskScore).toBe(0);\n      expect(responseTime).toBeLessThan(200); // <200ms requirement\n    });\n\n    test('should allow payment token validation during crisis', async () => {\n      // Create token in normal mode\n      const tokenResult = await paymentSecurity.createPaymentToken(\n        { test: 'token' },\n        'test_user',\n        'test_device',\n        'test_session'\n      );\n\n      // Validate in crisis mode\n      const startTime = Date.now();\n      const validationResult = await paymentSecurity.validatePaymentToken(\n        tokenResult.tokenInfo.tokenId,\n        'test_user',\n        'test_device',\n        true // Crisis mode\n      );\n\n      const responseTime = Date.now() - startTime;\n\n      expect(validationResult.success).toBe(true);\n      expect(validationResult.crisisOverride).toBe(true);\n      expect(responseTime).toBeLessThan(200); // <200ms requirement\n    });\n\n    test('should exempt crisis mode from rate limiting', async () => {\n      const userId = 'crisis_rate_test';\n      const deviceId = 'crisis_device';\n\n      // Make many attempts in crisis mode\n      const promises = [];\n      for (let i = 0; i < 20; i++) {\n        promises.push(\n          paymentSecurity.createPaymentToken(\n            { crisis: 'payment' },\n            userId,\n            deviceId,\n            `crisis_session_${i}`,\n            true // Crisis mode\n          )\n        );\n      }\n\n      const results = await Promise.all(promises);\n\n      // All should succeed in crisis mode (no rate limiting)\n      const successes = results.filter(r => r.securityResult.success);\n      expect(successes.length).toBe(20);\n\n      // All should have crisis override\n      const crisisOverrides = results.filter(r => r.securityResult.crisisOverride);\n      expect(crisisOverrides.length).toBe(20);\n    });\n\n    test('should maintain 988 hotline access regardless of payment status', async () => {\n      // Simulate payment system failure\n      const originalCreateToken = paymentSecurity.createPaymentToken;\n\n      // Mock payment failure\n      jest.spyOn(paymentSecurity, 'createPaymentToken').mockRejectedValue(\n        new Error('Payment system unavailable')\n      );\n\n      // Crisis access should still work\n      try {\n        const result = await paymentSecurity.createPaymentToken(\n          { emergency: 'call' },\n          'emergency_user',\n          'emergency_device',\n          'emergency_session',\n          true // Crisis mode\n        );\n\n        // Should not reach here with mocked failure, unless crisis bypass works\n        expect(result.securityResult.crisisOverride).toBe(true);\n      } catch (error) {\n        // If error occurs, verify it's not blocking emergency features\n        expect(error.message).not.toContain('988');\n        expect(error.message).not.toContain('hotline');\n        expect(error.message).not.toContain('crisis');\n      }\n\n      // Restore original method\n      jest.restoreAllMocks();\n    });\n\n    test('should handle emergency cleanup without breaking crisis access', async () => {\n      await paymentSecurity.emergencyCleanup();\n\n      // Crisis access should still work after cleanup\n      const result = await paymentSecurity.createPaymentToken(\n        { post_cleanup: 'test' },\n        'cleanup_user',\n        'cleanup_device',\n        'cleanup_session',\n        true // Crisis mode\n      );\n\n      expect(result.securityResult.success).toBe(true);\n      expect(result.securityResult.crisisOverride).toBe(true);\n    });\n  });\n\n  describe('Fraud Detection', () => {\n    test('should detect high-risk payment patterns', async () => {\n      const userId = 'fraud_test_user';\n      const deviceId = 'suspicious_device';\n\n      // Create multiple rapid payment attempts\n      const promises = [];\n      for (let i = 0; i < 5; i++) {\n        promises.push(\n          paymentSecurity.createPaymentToken(\n            {\n              amount: 10000, // High amount\n              rapid_attempt: i\n            },\n            userId,\n            deviceId,\n            `rapid_session_${i}`\n          ).catch(err => err)\n        );\n      }\n\n      const results = await Promise.all(promises);\n\n      // Some should be flagged for high risk\n      const highRiskResults = results.filter(r =>\n        r.securityResult && r.securityResult.riskScore > 50\n      );\n\n      expect(highRiskResults.length).toBeGreaterThan(0);\n    });\n\n    test('should allow legitimate payment patterns', async () => {\n      const result = await paymentSecurity.createPaymentToken(\n        {\n          amount: 999, // Normal subscription amount\n          legitimate: true\n        },\n        'good_user',\n        'trusted_device',\n        'normal_session'\n      );\n\n      expect(result.securityResult.success).toBe(true);\n      expect(result.securityResult.riskScore).toBeLessThan(50);\n      expect(result.securityResult.action).toEqual(\n        expect.stringMatching(/proceed|challenge/)\n      );\n    });\n\n    test('should never block crisis operations due to fraud detection', async () => {\n      // Even with suspicious patterns, crisis mode should work\n      const result = await paymentSecurity.createPaymentToken(\n        {\n          amount: 100000, // Suspicious high amount\n          suspicious: 'pattern'\n        },\n        'suspicious_user',\n        'unknown_device',\n        'suspicious_session',\n        true // Crisis mode\n      );\n\n      expect(result.securityResult.success).toBe(true);\n      expect(result.securityResult.crisisOverride).toBe(true);\n      expect(result.securityResult.riskScore).toBe(0); // Risk ignored in crisis\n    });\n  });\n\n  describe('Data Isolation', () => {\n    test('should use separate encryption keys for payment vs PHI data', async () => {\n      // This test would verify that payment and health data use different encryption contexts\n      // In real implementation, would check key derivation and storage separation\n\n      const paymentStatus = await paymentSecurity.getPaymentSecurityStatus();\n      expect(paymentStatus.pciCompliant).toBe(true);\n\n      // Verify payment encryption is separate from health data encryption\n      const encryptionStatus = await encryptionService.getSecurityReadiness();\n      expect(encryptionStatus.ready).toBe(true);\n\n      // Both should be ready but with separate security contexts\n      expect(paymentStatus.pciCompliant).toBe(true);\n      expect(encryptionStatus.cloudSyncReady).toBe(true);\n    });\n\n    test('should maintain separate audit trails for payment vs health data', async () => {\n      await paymentSecurity.createPaymentToken(\n        { payment: 'data' },\n        'audit_user',\n        'audit_device',\n        'payment_audit_session'\n      );\n\n      // Payment audit should be separate from health data audit\n      // In real implementation, would verify separate audit log storage\n      expect(true).toBe(true); // Placeholder for audit separation verification\n    });\n  });\n\n  describe('Performance Requirements', () => {\n    test('should meet <200ms crisis response time requirement', async () => {\n      const iterations = 10;\n      const responseTimes: number[] = [];\n\n      for (let i = 0; i < iterations; i++) {\n        const startTime = Date.now();\n\n        await paymentSecurity.createPaymentToken(\n          { performance: 'test' },\n          'perf_user',\n          'perf_device',\n          `perf_session_${i}`,\n          true // Crisis mode\n        );\n\n        const responseTime = Date.now() - startTime;\n        responseTimes.push(responseTime);\n      }\n\n      const averageResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;\n      const maxResponseTime = Math.max(...responseTimes);\n\n      expect(averageResponseTime).toBeLessThan(100); // Target <100ms average\n      expect(maxResponseTime).toBeLessThan(200); // Never exceed 200ms\n\n      console.log(`Crisis response times - Avg: ${averageResponseTime}ms, Max: ${maxResponseTime}ms`);\n    });\n\n    test('should maintain performance under load', async () => {\n      const concurrentRequests = 20;\n      const startTime = Date.now();\n\n      const promises = Array.from({ length: concurrentRequests }, (_, i) =>\n        paymentSecurity.createPaymentToken(\n          { load: 'test' },\n          `load_user_${i}`,\n          `load_device_${i}`,\n          `load_session_${i}`,\n          true // Crisis mode for consistent performance\n        )\n      );\n\n      const results = await Promise.all(promises);\n      const totalTime = Date.now() - startTime;\n      const averageTime = totalTime / concurrentRequests;\n\n      expect(results.length).toBe(concurrentRequests);\n      expect(averageTime).toBeLessThan(300); // Reasonable performance under load\n\n      const successCount = results.filter(r => r.securityResult.success).length;\n      expect(successCount).toBe(concurrentRequests);\n    });\n  });\n\n  describe('Token Lifecycle Management', () => {\n    test('should enforce token expiration', async () => {\n      const result = await paymentSecurity.createPaymentToken(\n        { test: 'expiry' },\n        'expiry_user',\n        'expiry_device',\n        'expiry_session'\n      );\n\n      // Mock token as expired\n      const tokenInfo = result.tokenInfo;\n      tokenInfo.expires = new Date(Date.now() - 1000).toISOString(); // 1 second ago\n\n      // Validation should fail for expired token\n      const validationResult = await paymentSecurity.validatePaymentToken(\n        tokenInfo.tokenId,\n        'expiry_user',\n        'expiry_device'\n      );\n\n      expect(validationResult.success).toBe(false);\n      expect(validationResult.reason).toContain('expired');\n    });\n\n    test('should handle token cleanup gracefully', async () => {\n      // Create several tokens\n      const tokens = [];\n      for (let i = 0; i < 5; i++) {\n        const result = await paymentSecurity.createPaymentToken(\n          { cleanup: `test_${i}` },\n          'cleanup_user',\n          'cleanup_device',\n          `cleanup_session_${i}`\n        );\n        tokens.push(result.tokenInfo.tokenId);\n      }\n\n      // Cleanup should not throw errors\n      await expect(paymentSecurity.emergencyCleanup()).resolves.not.toThrow();\n\n      // Crisis mode should still work after cleanup\n      const postCleanupResult = await paymentSecurity.createPaymentToken(\n        { post_cleanup: 'test' },\n        'cleanup_user',\n        'cleanup_device',\n        'post_cleanup_session',\n        true // Crisis mode\n      );\n\n      expect(postCleanupResult.securityResult.success).toBe(true);\n    });\n  });\n\n  describe('Error Handling and Resilience', () => {\n    test('should handle encryption failures gracefully', async () => {\n      // Mock encryption failure\n      const originalEncrypt = encryptionService.encryptData;\n      jest.spyOn(encryptionService, 'encryptData').mockRejectedValue(\n        new Error('Encryption failed')\n      );\n\n      try {\n        await paymentSecurity.createPaymentToken(\n          { error: 'test' },\n          'error_user',\n          'error_device',\n          'error_session'\n        );\n\n        // Should throw error for normal mode\n        expect(true).toBe(false); // Should not reach here\n      } catch (error) {\n        expect(error.message).toContain('Payment security failure');\n      }\n\n      // Crisis mode should still work even with encryption failure\n      const crisisResult = await paymentSecurity.createPaymentToken(\n        { crisis_error: 'test' },\n        'error_user',\n        'error_device',\n        'crisis_error_session',\n        true // Crisis mode\n      );\n\n      expect(crisisResult.securityResult.crisisOverride).toBe(true);\n\n      // Restore original method\n      jest.restoreAllMocks();\n    });\n\n    test('should maintain service availability during partial failures', async () => {\n      // Test resilience to various failure scenarios\n      const testCases = [\n        { scenario: 'network_error', data: { network: 'failed' } },\n        { scenario: 'device_error', data: { device: 'unavailable' } },\n        { scenario: 'storage_error', data: { storage: 'full' } }\n      ];\n\n      for (const testCase of testCases) {\n        // Crisis mode should work regardless of other failures\n        const result = await paymentSecurity.createPaymentToken(\n          testCase.data,\n          'resilience_user',\n          'resilience_device',\n          `resilience_${testCase.scenario}`,\n          true // Crisis mode\n        );\n\n        expect(result.securityResult.success).toBe(true);\n        expect(result.securityResult.crisisOverride).toBe(true);\n      }\n    });\n  });\n\n  describe('Security Validation', () => {\n    test('should validate PCI DSS compliance requirements', async () => {\n      const status = await paymentSecurity.getPaymentSecurityStatus();\n\n      // All PCI DSS requirements should be met\n      expect(status.pciCompliant).toBe(true);\n      expect(status.fraudDetectionActive).toBe(true);\n      expect(status.crisisBypassEnabled).toBe(true);\n      expect(status.issues).toHaveLength(0);\n    });\n\n    test('should enforce biometric authentication for payment operations', async () => {\n      // Normal payment operations should require biometric auth\n      const result = await paymentSecurity.createPaymentToken(\n        { biometric: 'test' },\n        'biometric_user',\n        'biometric_device',\n        'biometric_session'\n      );\n\n      // In production, would verify biometric challenge was required\n      expect(result.securityResult.success).toBe(true);\n    });\n\n    test('should validate device binding for payment tokens', async () => {\n      const result = await paymentSecurity.createPaymentToken(\n        { device: 'binding' },\n        'device_user',\n        'original_device',\n        'device_session'\n      );\n\n      // Try to validate token from different device\n      const validationResult = await paymentSecurity.validatePaymentToken(\n        result.tokenInfo.tokenId,\n        'device_user',\n        'different_device' // Different device\n      );\n\n      // Should fail due to device binding\n      expect(validationResult.success).toBe(false);\n      expect(validationResult.reason).toContain('Device binding');\n    });\n  });\n});",
          "size": 18968,
          "lines": 575,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": true,
          "hasAsyncTests": true,
          "hasExpectations": true
        }
      ],
      "totalFiles": 1,
      "existingFiles": 1,
      "totalLines": 575,
      "hasTests": 1,
      "requirements": [
        "PCI DSS Level 2 compliance validation",
        "Payment tokenization security",
        "No sensitive data storage verification",
        "Comprehensive audit logging",
        "Crisis data protection during payments"
      ],
      "coverage": 100
    },
    "integration": {
      "name": "Integration Testing",
      "icon": "ðŸ”—",
      "files": [
        {
          "path": "__tests__/integration/assessment-flow.test.tsx",
          "exists": true,
          "content": "/**\n * Assessment Flow Integration Tests\n * \n * Tests complete user journey from assessment start to crisis intervention\n * Validates the critical path that protects user safety\n */\n\nimport React from 'react';\nimport { render, fireEvent, waitFor, act } from '@testing-library/react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { useAssessmentStore } from '../../src/store/assessmentStore';\n\n// Mock the assessment flow components\njest.mock('../../src/flows/assessment/AssessmentFlow', () => {\n  const React = require('react');\n  const { View, Text, TouchableOpacity } = require('react-native');\n  \n  return function MockAssessmentFlow({ onComplete }: { onComplete: (result: any) => void }) {\n    const [currentQuestion, setCurrentQuestion] = React.useState(0);\n    const [answers, setAnswers] = React.useState<number[]>([]);\n    \n    const questions = [\n      'Little interest or pleasure in doing things',\n      'Feeling down, depressed, or hopeless',\n      'Trouble falling or staying asleep',\n      'Feeling tired or having little energy',\n      'Poor appetite or overeating',\n      'Feeling bad about yourself',\n      'Trouble concentrating',\n      'Moving or speaking slowly',\n      'Thoughts that you would be better off dead' // Critical question 9\n    ];\n    \n    const handleAnswer = (value: number) => {\n      const newAnswers = [...answers, value];\n      setAnswers(newAnswers);\n      \n      if (currentQuestion < questions.length - 1) {\n        setCurrentQuestion(currentQuestion + 1);\n      } else {\n        // Complete assessment\n        const score = newAnswers.reduce((sum, answer) => sum + answer, 0);\n        onComplete({\n          answers: newAnswers,\n          score,\n          completed: true\n        });\n      }\n    };\n    \n    if (currentQuestion >= questions.length) {\n      return (\n        <View testID=\"assessment-completed\">\n          <Text>Assessment completed</Text>\n        </View>\n      );\n    }\n    \n    return (\n      <View testID=\"assessment-flow\">\n        <Text testID={`question-${currentQuestion}`}>\n          Question {currentQuestion + 1}: {questions[currentQuestion]}\n        </Text>\n        <TouchableOpacity testID=\"answer-0\" onPress={() => handleAnswer(0)}>\n          <Text>Not at all</Text>\n        </TouchableOpacity>\n        <TouchableOpacity testID=\"answer-1\" onPress={() => handleAnswer(1)}>\n          <Text>Several days</Text>\n        </TouchableOpacity>\n        <TouchableOpacity testID=\"answer-2\" onPress={() => handleAnswer(2)}>\n          <Text>More than half the days</Text>\n        </TouchableOpacity>\n        <TouchableOpacity testID=\"answer-3\" onPress={() => handleAnswer(3)}>\n          <Text>Nearly every day</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  };\n});\n\n// Mock crisis screen\nconst MockCrisisScreen = ({ assessment }: { assessment: any }) => (\n  <View testID=\"crisis-screen\">\n    <Text testID=\"crisis-title\">Crisis Support</Text>\n    <Text testID=\"crisis-score\">Score: {assessment.score}</Text>\n    <TouchableOpacity testID=\"call-988\">\n      <Text>Call 988</Text>\n    </TouchableOpacity>\n  </View>\n);\n\ndescribe('Assessment Flow Integration Tests', () => {\n  let store: ReturnType<typeof useAssessmentStore.getState>;\n\n  beforeEach(async () => {\n    await AsyncStorage.clear();\n    store = useAssessmentStore.getState();\n    store.clearCurrentAssessment();\n  });\n\n  describe('Complete PHQ-9 Flow - Normal Case', () => {\n    test('Mild Depression Assessment (Score 8)', async () => {\n      // Start assessment\n      act(() => {\n        store.startAssessment('phq9', 'standalone');\n      });\n\n      const AssessmentWrapper = () => {\n        const [result, setResult] = React.useState<any>(null);\n        const [showCrisis, setShowCrisis] = React.useState(false);\n        \n        const handleComplete = async (assessmentResult: any) => {\n          setResult(assessmentResult);\n          \n          // Simulate the assessment store logic\n          const assessment = {\n            id: 'test_assessment',\n            type: 'phq9',\n            answers: assessmentResult.answers,\n            score: assessmentResult.score,\n            severity: assessmentResult.score <= 4 ? 'minimal' : \n                      assessmentResult.score <= 9 ? 'mild' :\n                      assessmentResult.score <= 14 ? 'moderate' :\n                      assessmentResult.score <= 19 ? 'moderately severe' : 'severe',\n            completedAt: new Date().toISOString(),\n            context: 'standalone'\n          };\n          \n          // Check for crisis (score >= 20 or question 9 > 0)\n          const needsCrisis = assessment.score >= 20 || assessment.answers[8] > 0;\n          setShowCrisis(needsCrisis);\n          \n          // Save to store\n          await store.saveAssessment();\n        };\n        \n        if (showCrisis) {\n          return <MockCrisisScreen assessment={result} />;\n        }\n        \n        if (result) {\n          return (\n            <View testID=\"assessment-results\">\n              <Text testID=\"result-score\">Score: {result.score}</Text>\n              <Text testID=\"result-severity\">Mild Depression</Text>\n            </View>\n          );\n        }\n        \n        return (\n          <MockAssessmentFlow onComplete={handleComplete} />\n        );\n      };\n\n      const { getByTestId } = render(<AssessmentWrapper />);\n\n      // Answer all 9 questions with mild depression pattern\n      const mildAnswers = [1, 1, 1, 1, 1, 1, 1, 1, 0]; // Score: 8, No suicidal ideation\n\n      for (let i = 0; i < 9; i++) {\n        await waitFor(() => {\n          expect(getByTestId(`question-${i}`)).toBeTruthy();\n        });\n        \n        fireEvent.press(getByTestId(`answer-${mildAnswers[i]}`));\n        \n        if (i < 8) {\n          await waitFor(() => {\n            expect(getByTestId(`question-${i + 1}`)).toBeTruthy();\n          });\n        }\n      }\n\n      // Verify results screen (not crisis)\n      await waitFor(() => {\n        expect(getByTestId('assessment-results')).toBeTruthy();\n        expect(getByTestId('result-score')).toHaveTextContent('Score: 8');\n        expect(getByTestId('result-severity')).toHaveTextContent('Mild Depression');\n      });\n\n      // Verify no crisis screen\n      expect(() => getByTestId('crisis-screen')).toThrow();\n    });\n  });\n\n  describe('Crisis Intervention Flows', () => {\n    test('Severe Depression (Score 21) - Crisis Triggered', async () => {\n      const CrisisAssessmentWrapper = () => {\n        const [result, setResult] = React.useState<any>(null);\n        const [showCrisis, setShowCrisis] = React.useState(false);\n        \n        const handleComplete = async (assessmentResult: any) => {\n          setResult(assessmentResult);\n          \n          // High score assessment\n          const assessment = {\n            id: 'crisis_test',\n            type: 'phq9',\n            answers: assessmentResult.answers,\n            score: assessmentResult.score,\n            severity: 'severe',\n            completedAt: new Date().toISOString(),\n            context: 'standalone'\n          };\n          \n          // Should trigger crisis for score >= 20\n          const needsCrisis = assessment.score >= 20 || assessment.answers[8] > 0;\n          setShowCrisis(needsCrisis);\n        };\n        \n        if (showCrisis && result) {\n          return <MockCrisisScreen assessment={result} />;\n        }\n        \n        return <MockAssessmentFlow onComplete={handleComplete} />;\n      };\n\n      const { getByTestId } = render(<CrisisAssessmentWrapper />);\n\n      // Answer with severe depression (score 21)\n      const severeAnswers = [3, 3, 3, 3, 3, 3, 3, 0, 0]; // Score: 21\n\n      for (let i = 0; i < 9; i++) {\n        await waitFor(() => {\n          expect(getByTestId(`question-${i}`)).toBeTruthy();\n        });\n        \n        fireEvent.press(getByTestId(`answer-${severeAnswers[i]}`));\n      }\n\n      // Verify crisis screen is shown\n      await waitFor(() => {\n        expect(getByTestId('crisis-screen')).toBeTruthy();\n        expect(getByTestId('crisis-title')).toHaveTextContent('Crisis Support');\n        expect(getByTestId('crisis-score')).toHaveTextContent('Score: 21');\n        expect(getByTestId('call-988')).toBeTruthy();\n      });\n    });\n\n    test('Suicidal Ideation (Low Score) - Crisis Triggered', async () => {\n      const SuicidalIdeationWrapper = () => {\n        const [result, setResult] = React.useState<any>(null);\n        const [showCrisis, setShowCrisis] = React.useState(false);\n        \n        const handleComplete = async (assessmentResult: any) => {\n          setResult(assessmentResult);\n          \n          const assessment = {\n            id: 'suicidal_test',\n            type: 'phq9', \n            answers: assessmentResult.answers,\n            score: assessmentResult.score,\n            severity: 'minimal', // Low score but has suicidal ideation\n            completedAt: new Date().toISOString(),\n            context: 'standalone'\n          };\n          \n          // Should trigger crisis for question 9 > 0 regardless of total score\n          const needsCrisis = assessment.score >= 20 || assessment.answers[8] > 0;\n          setShowCrisis(needsCrisis);\n        };\n        \n        if (showCrisis && result) {\n          return <MockCrisisScreen assessment={result} />;\n        }\n        \n        return <MockAssessmentFlow onComplete={handleComplete} />;\n      };\n\n      const { getByTestId } = render(<SuicidalIdeationWrapper />);\n\n      // Low total score but positive suicidal ideation\n      const suicidalAnswers = [0, 0, 0, 0, 0, 0, 0, 0, 1]; // Score: 1, but question 9 = 1\n\n      for (let i = 0; i < 9; i++) {\n        await waitFor(() => {\n          expect(getByTestId(`question-${i}`)).toBeTruthy();\n        });\n        \n        fireEvent.press(getByTestId(`answer-${suicidalAnswers[i]}`));\n      }\n\n      // Verify crisis screen is triggered despite low total score\n      await waitFor(() => {\n        expect(getByTestId('crisis-screen')).toBeTruthy();\n        expect(getByTestId('crisis-title')).toHaveTextContent('Crisis Support');\n        expect(getByTestId('crisis-score')).toHaveTextContent('Score: 1');\n      });\n    });\n\n    test('GAD-7 Severe Anxiety (Score 16) - Crisis Triggered', async () => {\n      // Mock GAD-7 assessment\n      const MockGAD7Flow = ({ onComplete }: { onComplete: (result: any) => void }) => {\n        const [currentQuestion, setCurrentQuestion] = React.useState(0);\n        const [answers, setAnswers] = React.useState<number[]>([]);\n        \n        const questions = [\n          'Feeling nervous, anxious, or on edge',\n          'Not being able to stop or control worrying',\n          'Worrying too much about different things',\n          'Trouble relaxing',\n          'Being so restless',\n          'Becoming easily annoyed or irritable',\n          'Feeling afraid as if something awful might happen'\n        ];\n        \n        const handleAnswer = (value: number) => {\n          const newAnswers = [...answers, value];\n          setAnswers(newAnswers);\n          \n          if (currentQuestion < questions.length - 1) {\n            setCurrentQuestion(currentQuestion + 1);\n          } else {\n            const score = newAnswers.reduce((sum, answer) => sum + answer, 0);\n            onComplete({\n              answers: newAnswers,\n              score,\n              completed: true\n            });\n          }\n        };\n        \n        return (\n          <View testID=\"gad7-assessment\">\n            <Text testID={`gad7-question-${currentQuestion}`}>\n              GAD-7 Q{currentQuestion + 1}: {questions[currentQuestion]}\n            </Text>\n            {[0, 1, 2, 3].map(value => (\n              <TouchableOpacity \n                key={value}\n                testID={`gad7-answer-${value}`} \n                onPress={() => handleAnswer(value)}\n              >\n                <Text>{['Not at all', 'Several days', 'More than half', 'Nearly every day'][value]}</Text>\n              </TouchableOpacity>\n            ))}\n          </View>\n        );\n      };\n\n      const GAD7CrisisWrapper = () => {\n        const [result, setResult] = React.useState<any>(null);\n        const [showCrisis, setShowCrisis] = React.useState(false);\n        \n        const handleComplete = async (assessmentResult: any) => {\n          setResult(assessmentResult);\n          \n          const assessment = {\n            id: 'gad7_crisis',\n            type: 'gad7',\n            answers: assessmentResult.answers,\n            score: assessmentResult.score,\n            severity: 'severe',\n            completedAt: new Date().toISOString(),\n            context: 'standalone'\n          };\n          \n          // GAD-7 crisis threshold is score >= 15\n          const needsCrisis = assessment.score >= 15;\n          setShowCrisis(needsCrisis);\n        };\n        \n        if (showCrisis && result) {\n          return <MockCrisisScreen assessment={result} />;\n        }\n        \n        return <MockGAD7Flow onComplete={handleComplete} />;\n      };\n\n      const { getByTestId } = render(<GAD7CrisisWrapper />);\n\n      // Severe anxiety answers (score 16)\n      const severeAnxietyAnswers = [3, 3, 2, 2, 2, 2, 2]; // Score: 16\n\n      for (let i = 0; i < 7; i++) {\n        await waitFor(() => {\n          expect(getByTestId(`gad7-question-${i}`)).toBeTruthy();\n        });\n        \n        fireEvent.press(getByTestId(`gad7-answer-${severeAnxietyAnswers[i]}`));\n      }\n\n      // Verify crisis screen is triggered\n      await waitFor(() => {\n        expect(getByTestId('crisis-screen')).toBeTruthy();\n        expect(getByTestId('crisis-score')).toHaveTextContent('Score: 16');\n      });\n    });\n  });\n\n  describe('Assessment Persistence During Flow', () => {\n    test('Auto-save Progress During Assessment', async () => {\n      act(() => {\n        store.startAssessment('phq9', 'standalone');\n      });\n\n      // Verify assessment started\n      const currentAssessment = store.currentAssessment;\n      expect(currentAssessment).not.toBeNull();\n      expect(currentAssessment!.config!.type).toBe('phq9');\n\n      // Answer first few questions\n      act(() => {\n        store.answerQuestion(2);\n        store.answerQuestion(1);\n        store.answerQuestion(1);\n      });\n\n      const progress = store.getCurrentProgress();\n      expect(progress.current).toBe(3);\n      expect(progress.total).toBe(9);\n\n      // Verify answers are stored\n      expect(store.currentAssessment!.answers[0]).toBe(2);\n      expect(store.currentAssessment!.answers[1]).toBe(1);\n      expect(store.currentAssessment!.answers[2]).toBe(1);\n    });\n\n    test('Assessment Data Validation Before Save', async () => {\n      act(() => {\n        store.startAssessment('phq9', 'standalone');\n      });\n\n      // Try to save incomplete assessment\n      const savePromise = store.saveAssessment();\n      await expect(savePromise).rejects.toThrow('Please answer all questions');\n\n      // Complete all questions\n      for (let i = 0; i < 9; i++) {\n        act(() => {\n          store.answerQuestion(1);\n        });\n      }\n\n      // Now save should work\n      await expect(store.saveAssessment()).resolves.not.toThrow();\n    });\n  });\n\n  describe('Error Handling in Assessment Flow', () => {\n    test('Storage Failure During Assessment Save', async () => {\n      // Mock storage failure\n      const originalSetItem = AsyncStorage.setItem;\n      AsyncStorage.setItem = jest.fn().mockRejectedValue(new Error('Storage failed'));\n\n      act(() => {\n        store.startAssessment('phq9', 'standalone');\n      });\n\n      // Complete assessment\n      for (let i = 0; i < 9; i++) {\n        act(() => {\n          store.answerQuestion(1);\n        });\n      }\n\n      // Save should fail gracefully\n      await expect(store.saveAssessment()).rejects.toThrow('Failed to save assessment');\n\n      // Restore storage\n      AsyncStorage.setItem = originalSetItem;\n    });\n\n    test('Navigation During Assessment - State Preservation', async () => {\n      act(() => {\n        store.startAssessment('gad7', 'standalone');\n      });\n\n      // Answer some questions\n      act(() => {\n        store.answerQuestion(2);\n        store.answerQuestion(3);\n      });\n\n      const beforeNavigation = {\n        currentQuestion: store.currentAssessment!.currentQuestion,\n        answers: [...store.currentAssessment!.answers]\n      };\n\n      // Simulate app backgrounding/foregrounding\n      // State should be preserved\n      expect(store.currentAssessment!.currentQuestion).toBe(beforeNavigation.currentQuestion);\n      expect(store.currentAssessment!.answers).toEqual(beforeNavigation.answers);\n    });\n  });\n});",
          "size": 16565,
          "lines": 486,
          "hasTests": true,
          "hasDescribeBlocks": true,
          "hasMocks": true,
          "hasAsyncTests": true,
          "hasExpectations": true
        }
      ],
      "totalFiles": 1,
      "existingFiles": 1,
      "totalLines": 486,
      "hasTests": 1,
      "requirements": [
        "Payment store integration with userStore",
        "Authentication system integration for subscriptions",
        "Cloud sync for payment status across devices",
        "Feature flag integration for payment tiers",
        "Error boundary testing for payment components"
      ],
      "coverage": 100
    }
  },
  "readyForDeployment": true
}